/*!
In the following section you can find a detaild description of the current API version 3.1.
\list
\li \l{Types}
\li \l{Methods}
\li \l{Notifications}
\endlist
\section1 Types
\section2 Action
\code
{
    "actionTypeId": "Uuid", 
    "deviceId": "Uuid", 
    "o:params": [
        "$ref:Param"
    ]
}
\endcode
See also: \l{Param}
\section2 ActionType
\code
{
    "displayName": "String", 
    "id": "Uuid", 
    "index": "Int", 
    "name": "String", 
    "paramTypes": [
        "$ref:ParamType"
    ]
}
\endcode
See also: \l{ParamType}
\section2 BasicType
\code
[
    "Uuid", 
    "String", 
    "StringList", 
    "Int", 
    "Uint", 
    "Double", 
    "Bool", 
    "Variant", 
    "Color", 
    "Time", 
    "Object"
]
\endcode
\section2 BrowserIcon
\code
[
    "BrowserIconNone", 
    "BrowserIconFolder", 
    "BrowserIconFile", 
    "BrowserIconMusic", 
    "BrowserIconVideo", 
    "BrowserIconPictures", 
    "BrowserIconApplication", 
    "BrowserIconDocument", 
    "BrowserIconPackage", 
    "BrowserIconFavorites"
]
\endcode
\section2 BrowserItem
\code
{
    "actionTypeIds": [
        "Uuid"
    ], 
    "browsable": "Bool", 
    "description": "String", 
    "disabled": "Bool", 
    "displayName": "String", 
    "executable": "Bool", 
    "icon": "$ref:BrowserIcon", 
    "id": "String", 
    "o:mediaIcon": "$ref:MediaBrowserIcon", 
    "thumbnail": "String"
}
\endcode
See also: \l{MediaBrowserIcon}, \l{BrowserIcon}
\section2 CalendarItem
\code
{
    "duration": "Uint", 
    "o:datetime": "Uint", 
    "o:repeating": "$ref:RepeatingOption", 
    "o:startTime": "Time"
}
\endcode
See also: \l{RepeatingOption}
\section2 CloudConnectionState
\code
[
    "CloudConnectionStateDisabled", 
    "CloudConnectionStateUnconfigured", 
    "CloudConnectionStateConnecting", 
    "CloudConnectionStateConnected"
]
\endcode
\section2 ConfigurationError
\code
[
    "ConfigurationErrorNoError", 
    "ConfigurationErrorInvalidTimeZone", 
    "ConfigurationErrorInvalidStationName", 
    "ConfigurationErrorInvalidId", 
    "ConfigurationErrorInvalidPort", 
    "ConfigurationErrorInvalidHostAddress", 
    "ConfigurationErrorBluetoothHardwareNotAvailable", 
    "ConfigurationErrorInvalidCertificate"
]
\endcode
\section2 CreateMethod
\code
[
    "CreateMethodUser", 
    "CreateMethodAuto", 
    "CreateMethodDiscovery"
]
\endcode
\section2 Device
\code
{
    "thingClassId": "Uuid", 
    "id": "Uuid", 
    "name": "String", 
    "o:parentId": "Uuid", 
    "params": [
        "$ref:Param"
    ], 
    "settings": [
        "$ref:Param"
    ], 
    "setupComplete": "Bool", 
    "states": [
        {
            "stateTypeId": "Uuid", 
            "value": "Variant"
        }
    ]
}
\endcode
See also: \l{Param}, \l{Param}
\section2 DeviceClass
\code
{
    "actionTypes": [
        "$ref:ActionType"
    ], 
    "browsable": "Bool", 
    "browserItemActionTypes": [
        "$ref:ActionType"
    ], 
    "createMethods": [
        "$ref:CreateMethod"
    ], 
    "discoveryParamTypes": [
        "$ref:ParamType"
    ], 
    "displayName": "String", 
    "eventTypes": [
        "$ref:EventType"
    ], 
    "id": "Uuid", 
    "interfaces": [
        "String"
    ], 
    "name": "String", 
    "paramTypes": [
        "$ref:ParamType"
    ], 
    "pluginId": "Uuid", 
    "settingsTypes": [
        "$ref:ParamType"
    ], 
    "setupMethod": "$ref:SetupMethod", 
    "stateTypes": [
        "$ref:StateType"
    ], 
    "vendorId": "Uuid"
}
\endcode
See also: \l{ParamType}, \l{ActionType}, \l{CreateMethod}, \l{ParamType}, \l{ActionType}, \l{SetupMethod}, \l{StateType}, \l{EventType}, \l{ParamType}
\section2 DeviceDescriptor
\code
{
    "description": "String", 
    "deviceId": "Uuid", 
    "deviceParams": [
        "$ref:Param"
    ], 
    "id": "Uuid", 
    "title": "String"
}
\endcode
See also: \l{Param}
\section2 DeviceError
\code
[
    "DeviceErrorNoError", 
    "DeviceErrorPluginNotFound", 
    "DeviceErrorVendorNotFound", 
    "DeviceErrorDeviceNotFound", 
    "DeviceErrorDeviceClassNotFound", 
    "DeviceErrorActionTypeNotFound", 
    "DeviceErrorStateTypeNotFound", 
    "DeviceErrorEventTypeNotFound", 
    "DeviceErrorDeviceDescriptorNotFound", 
    "DeviceErrorMissingParameter", 
    "DeviceErrorInvalidParameter", 
    "DeviceErrorSetupFailed", 
    "DeviceErrorDuplicateUuid", 
    "DeviceErrorCreationMethodNotSupported", 
    "DeviceErrorSetupMethodNotSupported", 
    "DeviceErrorHardwareNotAvailable", 
    "DeviceErrorHardwareFailure", 
    "DeviceErrorAuthenticationFailure", 
    "DeviceErrorDeviceInUse", 
    "DeviceErrorDeviceInRule", 
    "DeviceErrorDeviceIsChild", 
    "DeviceErrorPairingTransactionIdNotFound", 
    "DeviceErrorParameterNotWritable", 
    "DeviceErrorItemNotFound", 
    "DeviceErrorItemNotExecutable", 
    "DeviceErrorUnsupportedFeature", 
    "DeviceErrorTimeout"
]
\endcode
\section2 Event
\code
{
    "deviceId": "Uuid", 
    "eventTypeId": "Uuid", 
    "o:params": [
        "$ref:Param"
    ]
}
\endcode
See also: \l{Param}
\section2 EventDescriptor
\code
{
    "o:deviceId": "Uuid", 
    "o:eventTypeId": "Uuid", 
    "o:interface": "String", 
    "o:interfaceEvent": "String", 
    "o:paramDescriptors": [
        "$ref:ParamDescriptor"
    ]
}
\endcode
See also: \l{ParamDescriptor}
\section2 EventType
\code
{
    "displayName": "String", 
    "id": "Uuid", 
    "index": "Int", 
    "name": "String", 
    "paramTypes": [
        "$ref:ParamType"
    ]
}
\endcode
See also: \l{ParamType}
\section2 InputType
\code
[
    "InputTypeNone", 
    "InputTypeTextLine", 
    "InputTypeTextArea", 
    "InputTypePassword", 
    "InputTypeSearch", 
    "InputTypeMail", 
    "InputTypeIPv4Address", 
    "InputTypeIPv6Address", 
    "InputTypeUrl", 
    "InputTypeMacAddress"
]
\endcode
\section2 LogEntry
\code
{
    "loggingLevel": "$ref:LoggingLevel", 
    "o:active": "Bool", 
    "o:deviceId": "Uuid", 
    "o:errorCode": "String", 
    "o:eventType": "$ref:LoggingEventType", 
    "o:itemId": "String", 
    "o:typeId": "Uuid", 
    "o:value": "String", 
    "source": "$ref:LoggingSource", 
    "timestamp": "Int"
}
\endcode
See also: \l{LoggingSource}, \l{LoggingEventType}, \l{LoggingLevel}
\section2 LoggingError
\code
[
    "LoggingErrorNoError", 
    "LoggingErrorLogEntryNotFound", 
    "LoggingErrorInvalidFilterParameter"
]
\endcode
\section2 LoggingEventType
\code
[
    "LoggingEventTypeTrigger", 
    "LoggingEventTypeActiveChange", 
    "LoggingEventTypeEnabledChange", 
    "LoggingEventTypeActionsExecuted", 
    "LoggingEventTypeExitActionsExecuted"
]
\endcode
\section2 LoggingLevel
\code
[
    "LoggingLevelInfo", 
    "LoggingLevelAlert"
]
\endcode
\section2 LoggingSource
\code
[
    "LoggingSourceSystem", 
    "LoggingSourceEvents", 
    "LoggingSourceActions", 
    "LoggingSourceStates", 
    "LoggingSourceRules", 
    "LoggingSourceBrowserActions"
]
\endcode
\section2 MediaBrowserIcon
\code
[
    "MediaBrowserIconNone", 
    "MediaBrowserIconPlaylist", 
    "MediaBrowserIconRecentlyPlayed", 
    "MediaBrowserIconLibrary", 
    "MediaBrowserIconMusicLibrary", 
    "MediaBrowserIconVideoLibrary", 
    "MediaBrowserIconPictureLibrary", 
    "MediaBrowserIconDisk", 
    "MediaBrowserIconUSB", 
    "MediaBrowserIconNetwork", 
    "MediaBrowserIconAux", 
    "MediaBrowserIconSpotify", 
    "MediaBrowserIconAmazon", 
    "MediaBrowserIconTuneIn", 
    "MediaBrowserIconSiriusXM", 
    "MediaBrowserIconVTuner", 
    "MediaBrowserIconTidal", 
    "MediaBrowserIconAirable", 
    "MediaBrowserIconDeezer", 
    "MediaBrowserIconNapster", 
    "MediaBrowserIconSoundCloud"
]
\endcode
\section2 MqttPolicy
\code
{
    "allowedPublishTopicFilters": "StringList", 
    "allowedSubscribeTopicFilters": "StringList", 
    "clientId": "String", 
    "password": "String", 
    "username": "String"
}
\endcode

\section2 Namespace
\code
[
    "Actions", 
    "Configuration", 
    "Devices", 
    "Events", 
    "JSONRPC", 
    "Logging", 
    "NetworkManager", 
    "Rules", 
    "States", 
    "System", 
    "Tags"
]
\endcode
\section2 NetworkDeviceState
\code
[
    "NetworkDeviceStateUnknown", 
    "NetworkDeviceStateUnmanaged", 
    "NetworkDeviceStateUnavailable", 
    "NetworkDeviceStateDisconnected", 
    "NetworkDeviceStatePrepare", 
    "NetworkDeviceStateConfig", 
    "NetworkDeviceStateNeedAuth", 
    "NetworkDeviceStateIpConfig", 
    "NetworkDeviceStateIpCheck", 
    "NetworkDeviceStateSecondaries", 
    "NetworkDeviceStateActivated", 
    "NetworkDeviceStateDeactivating", 
    "NetworkDeviceStateFailed"
]
\endcode
\section2 NetworkManagerError
\code
[
    "NetworkManagerErrorNoError", 
    "NetworkManagerErrorUnknownError", 
    "NetworkManagerErrorWirelessNotAvailable", 
    "NetworkManagerErrorAccessPointNotFound", 
    "NetworkManagerErrorNetworkInterfaceNotFound", 
    "NetworkManagerErrorInvalidNetworkDeviceType", 
    "NetworkManagerErrorWirelessNetworkingDisabled", 
    "NetworkManagerErrorWirelessConnectionFailed", 
    "NetworkManagerErrorNetworkingDisabled", 
    "NetworkManagerErrorNetworkManagerNotAvailable"
]
\endcode
\section2 NetworkManagerState
\code
[
    "NetworkManagerStateUnknown", 
    "NetworkManagerStateAsleep", 
    "NetworkManagerStateDisconnected", 
    "NetworkManagerStateDisconnecting", 
    "NetworkManagerStateConnecting", 
    "NetworkManagerStateConnectedLocal", 
    "NetworkManagerStateConnectedSite", 
    "NetworkManagerStateConnectedGlobal"
]
\endcode
\section2 Package
\code
{
    "canRemove": "Bool", 
    "candidateVersion": "String", 
    "changelog": "String", 
    "displayName": "String", 
    "id": "String", 
    "installedVersion": "String", 
    "rollbackAvailable": "Bool", 
    "summary": "String", 
    "updateAvailable": "Bool"
}
\endcode

\section2 Param
\code
{
    "paramTypeId": "Uuid", 
    "value": "$ref:BasicType"
}
\endcode
See also: \l{BasicType}
\section2 ParamDescriptor
\code
{
    "o:paramName": "Uuid", 
    "o:paramTypeId": "Uuid", 
    "operator": "$ref:ValueOperator", 
    "value": "$ref:BasicType"
}
\endcode
See also: \l{BasicType}, \l{ValueOperator}
\section2 ParamType
\code
{
    "displayName": "String", 
    "id": "Uuid", 
    "index": "Int", 
    "name": "String", 
    "o:allowedValues": [
        "Variant"
    ], 
    "o:defaultValue": "Variant", 
    "o:inputType": "$ref:InputType", 
    "o:maxValue": "Variant", 
    "o:minValue": "Variant", 
    "o:readOnly": "Bool", 
    "o:unit": "$ref:Unit", 
    "type": "$ref:BasicType"
}
\endcode
See also: \l{Unit}, \l{InputType}, \l{BasicType}
\section2 Plugin
\code
{
    "displayName": "String", 
    "id": "Uuid", 
    "name": "String", 
    "paramTypes": [
        "$ref:ParamType"
    ]
}
\endcode
See also: \l{ParamType}
\section2 RemovePolicy
\code
[
    "RemovePolicyCascade", 
    "RemovePolicyUpdate"
]
\endcode
\section2 RepeatingMode
\code
[
    "RepeatingModeNone", 
    "RepeatingModeHourly", 
    "RepeatingModeDaily", 
    "RepeatingModeWeekly", 
    "RepeatingModeMonthly", 
    "RepeatingModeYearly"
]
\endcode
\section2 RepeatingOption
\code
{
    "mode": "$ref:RepeatingMode", 
    "o:monthDays": [
        "Int"
    ], 
    "o:weekDays": [
        "Int"
    ]
}
\endcode
See also: \l{RepeatingMode}
\section2 Repository
\code
{
    "displayName": "String", 
    "enabled": "Bool", 
    "id": "String"
}
\endcode

\section2 Rule
\code
{
    "actions": [
        "$ref:RuleAction"
    ], 
    "active": "Bool", 
    "enabled": "Bool", 
    "eventDescriptors": [
        "$ref:EventDescriptor"
    ], 
    "executable": "Bool", 
    "exitActions": [
        "$ref:RuleAction"
    ], 
    "id": "Uuid", 
    "name": "String", 
    "stateEvaluator": "$ref:StateEvaluator", 
    "timeDescriptor": "$ref:TimeDescriptor"
}
\endcode
See also: \l{TimeDescriptor}, \l{RuleAction}, \l{StateEvaluator}, \l{RuleAction}, \l{EventDescriptor}
\section2 RuleAction
\code
{
    "o:actionTypeId": "Uuid", 
    "o:browserItemId": "String", 
    "o:deviceId": "Uuid", 
    "o:interface": "String", 
    "o:interfaceAction": "String", 
    "o:ruleActionParams": [
        "$ref:RuleActionParam"
    ]
}
\endcode
See also: \l{RuleActionParam}
\section2 RuleActionParam
\code
{
    "o:eventParamTypeId": "Uuid", 
    "o:eventTypeId": "Uuid", 
    "o:paramName": "String", 
    "o:paramTypeId": "Uuid", 
    "o:stateDeviceId": "Uuid", 
    "o:stateTypeId": "Uuid", 
    "o:value": "$ref:BasicType"
}
\endcode
See also: \l{BasicType}
\section2 RuleDescription
\code
{
    "active": "Bool", 
    "enabled": "Bool", 
    "executable": "Bool", 
    "id": "Uuid", 
    "name": "String"
}
\endcode

\section2 RuleError
\code
[
    "RuleErrorNoError", 
    "RuleErrorInvalidRuleId", 
    "RuleErrorRuleNotFound", 
    "RuleErrorDeviceNotFound", 
    "RuleErrorEventTypeNotFound", 
    "RuleErrorStateTypeNotFound", 
    "RuleErrorActionTypeNotFound", 
    "RuleErrorInvalidParameter", 
    "RuleErrorInvalidRuleFormat", 
    "RuleErrorMissingParameter", 
    "RuleErrorInvalidRuleActionParameter", 
    "RuleErrorInvalidStateEvaluatorValue", 
    "RuleErrorTypesNotMatching", 
    "RuleErrorNotExecutable", 
    "RuleErrorInvalidTimeDescriptor", 
    "RuleErrorInvalidRepeatingOption", 
    "RuleErrorInvalidCalendarItem", 
    "RuleErrorInvalidTimeEventItem", 
    "RuleErrorContainsEventBasesAction", 
    "RuleErrorNoExitActions", 
    "RuleErrorInterfaceNotFound"
]
\endcode
\section2 ServerConfiguration
\code
{
    "address": "String", 
    "authenticationEnabled": "Bool", 
    "id": "String", 
    "port": "Uint", 
    "sslEnabled": "Bool"
}
\endcode

\section2 SetupMethod
\code
[
    "SetupMethodJustAdd", 
    "SetupMethodDisplayPin", 
    "SetupMethodEnterPin", 
    "SetupMethodPushButton", 
    "SetupMethodUserAndPassword", 
    "SetupMethodOAuth"
]
\endcode
\section2 State
\code
{
    "deviceId": "Uuid", 
    "stateTypeId": "Uuid", 
    "value": "Variant"
}
\endcode

\section2 StateDescriptor
\code
{
    "o:deviceId": "Uuid", 
    "o:interface": "String", 
    "o:interfaceState": "String", 
    "o:stateTypeId": "Uuid", 
    "operator": "$ref:ValueOperator", 
    "value": "Variant"
}
\endcode
See also: \l{ValueOperator}
\section2 StateEvaluator
\code
{
    "o:childEvaluators": [
        "$ref:StateEvaluator"
    ], 
    "o:operator": "$ref:StateOperator", 
    "o:stateDescriptor": "$ref:StateDescriptor"
}
\endcode
See also: \l{StateEvaluator}, \l{StateDescriptor}, \l{StateOperator}
\section2 StateOperator
\code
[
    "StateOperatorAnd", 
    "StateOperatorOr"
]
\endcode
\section2 StateType
\code
{
    "defaultValue": "Variant", 
    "displayName": "String", 
    "id": "Uuid", 
    "index": "Int", 
    "name": "String", 
    "o:maxValue": "Variant", 
    "o:minValue": "Variant", 
    "o:possibleValues": [
        "Variant"
    ], 
    "o:unit": "$ref:Unit", 
    "type": "$ref:BasicType"
}
\endcode
See also: \l{Unit}, \l{BasicType}
\section2 Tag
\code
{
    "appId": "String", 
    "o:deviceId": "Uuid", 
    "o:ruleId": "Uuid", 
    "o:value": "String", 
    "tagId": "String"
}
\endcode

\section2 TagError
\code
[
    "TagErrorNoError", 
    "TagErrorDeviceNotFound", 
    "TagErrorRuleNotFound", 
    "TagErrorTagNotFound"
]
\endcode
\section2 TimeDescriptor
\code
{
    "o:calendarItems": [
        "$ref:CalendarItem"
    ], 
    "o:timeEventItems": [
        "$ref:TimeEventItem"
    ]
}
\endcode
See also: \l{TimeEventItem}, \l{CalendarItem}
\section2 TimeEventItem
\code
{
    "o:datetime": "Uint", 
    "o:repeating": "$ref:RepeatingOption", 
    "o:time": "Time"
}
\endcode
See also: \l{RepeatingOption}
\section2 TokenInfo
\code
{
    "creationTime": "Uint", 
    "deviceName": "String", 
    "id": "Uuid", 
    "userName": "String"
}
\endcode

\section2 Unit
\code
[
    "UnitNone", 
    "UnitSeconds", 
    "UnitMinutes", 
    "UnitHours", 
    "UnitUnixTime", 
    "UnitMeterPerSecond", 
    "UnitKiloMeterPerHour", 
    "UnitDegree", 
    "UnitRadiant", 
    "UnitDegreeCelsius", 
    "UnitDegreeKelvin", 
    "UnitMired", 
    "UnitMilliBar", 
    "UnitBar", 
    "UnitPascal", 
    "UnitHectoPascal", 
    "UnitAtmosphere", 
    "UnitLumen", 
    "UnitLux", 
    "UnitCandela", 
    "UnitMilliMeter", 
    "UnitCentiMeter", 
    "UnitMeter", 
    "UnitKiloMeter", 
    "UnitGram", 
    "UnitKiloGram", 
    "UnitDezibel", 
    "UnitBpm", 
    "UnitKiloByte", 
    "UnitMegaByte", 
    "UnitGigaByte", 
    "UnitTeraByte", 
    "UnitMilliWatt", 
    "UnitWatt", 
    "UnitKiloWatt", 
    "UnitKiloWattHour", 
    "UnitEuroPerMegaWattHour", 
    "UnitEuroCentPerKiloWattHour", 
    "UnitPercentage", 
    "UnitPartsPerMillion", 
    "UnitEuro", 
    "UnitDollar", 
    "UnitHertz", 
    "UnitAmpere", 
    "UnitMilliAmpere", 
    "UnitVolt", 
    "UnitMilliVolt", 
    "UnitVoltAmpere", 
    "UnitVoltAmpereReactive", 
    "UnitAmpereHour", 
    "UnitMicroSiemensPerCentimeter", 
    "UnitDuration"
]
\endcode
\section2 UserError
\code
[
    "UserErrorNoError", 
    "UserErrorBackendError", 
    "UserErrorInvalidUserId", 
    "UserErrorDuplicateUserId", 
    "UserErrorBadPassword", 
    "UserErrorTokenNotFound", 
    "UserErrorPermissionDenied"
]
\endcode
\section2 ValueOperator
\code
[
    "ValueOperatorEquals", 
    "ValueOperatorNotEquals", 
    "ValueOperatorLess", 
    "ValueOperatorGreater", 
    "ValueOperatorLessOrEqual", 
    "ValueOperatorGreaterOrEqual"
]
\endcode
\section2 Vendor
\code
{
    "displayName": "String", 
    "id": "Uuid", 
    "name": "String"
}
\endcode

\section2 WebServerConfiguration
\code
{
    "address": "String", 
    "authenticationEnabled": "Bool", 
    "id": "String", 
    "port": "Uint", 
    "sslEnabled": "Bool"
}
\endcode

\section2 WiredNetworkDevice
\code
{
    "bitRate": "String", 
    "interface": "String", 
    "macAddress": "String", 
    "pluggedIn": "Bool", 
    "state": "$ref:NetworkDeviceState"
}
\endcode
See also: \l{NetworkDeviceState}
\section2 WirelessAccessPoint
\code
{
    "frequency": "Double", 
    "macAddress": "String", 
    "protected": "Bool", 
    "signalStrength": "Int", 
    "ssid": "String"
}
\endcode

\section2 WirelessNetworkDevice
\code
{
    "bitRate": "String", 
    "interface": "String", 
    "macAddress": "String", 
    "o:currentAccessPoint": "$ref:WirelessAccessPoint", 
    "state": "$ref:NetworkDeviceState"
}
\endcode
See also: \l{WirelessAccessPoint}, \l{NetworkDeviceState}
\section1 Methods
\section2 Actions.ExecuteAction
Execute a single action.
Params
\code
{
    "actionTypeId": "Uuid", 
    "deviceId": "Uuid", 
    "o:params": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:displayMessage": "String"
}
\endcode
See also: \l{DeviceError}, \l{Param}
\section2 Actions.ExecuteBrowserItem
Execute the item identified by itemId on the given device.
Params
\code
{
    "deviceId": "Uuid", 
    "itemId": "String"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError"
}
\endcode
See also: \l{DeviceError}
\section2 Actions.ExecuteBrowserItemAction
Execute the action for the browser item identified by actionTypeId and the itemId on the given device.
Params
\code
{
    "actionTypeId": "Uuid", 
    "deviceId": "Uuid", 
    "itemId": "String", 
    "o:params": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError"
}
\endcode
See also: \l{DeviceError}, \l{Param}
\section2 Actions.GetActionType
Get the ActionType for the given ActionTypeId
Params
\code
{
    "actionTypeId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:actionType": {
        "displayName": "String", 
        "id": "Uuid", 
        "index": "Int", 
        "name": "String", 
        "paramTypes": [
            "$ref:ParamType"
        ]
    }
}
\endcode
See also: \l{ParamType}, \l{DeviceError}
\section2 Configuration.DeleteMqttPolicy
Delete a MQTT policy from the broker.
Params
\code
{
    "clientId": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.DeleteMqttServerConfiguration
Delete a MQTT Server interface of the server.
Params
\code
{
    "id": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.DeleteTcpServerConfiguration
Delete a TCP interface of the server. Note: if you are deleting the configuration for the interface you are currently connected to, the connection will be dropped.
Params
\code
{
    "id": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.DeleteWebServerConfiguration
Delete a WebServer interface of the server.
Params
\code
{
    "id": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.DeleteWebSocketServerConfiguration
Delete a WebSocket Server interface of the server. Note: if you are deleting the configuration for the interface you are currently connected to, the connection will be dropped.
Params
\code
{
    "id": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.GetAvailableLanguages
DEPRECATED - Use the locale property in the Handshake message instead - Returns a list of locale codes available for the server. i.e. en_US, de_AT
Params
\code
{}
\endcode
Returns
\code
{
    "languages": [
        "String"
    ]
}
\endcode

\section2 Configuration.GetConfigurations
Get all configuration parameters of the server.
Params
\code
{}
\endcode
Returns
\code
{
    "basicConfiguration": {
        "debugServerEnabled": "Bool", 
        "language": "String", 
        "serverName": "String", 
        "serverTime": "Uint", 
        "serverUuid": "Uuid", 
        "timeZone": "String"
    }, 
    "cloud": {
        "enabled": "Bool"
    }, 
    "tcpServerConfigurations": [
        "$ref:ServerConfiguration"
    ], 
    "webServerConfigurations": [
        "$ref:WebServerConfiguration"
    ], 
    "webSocketServerConfigurations": [
        "$ref:ServerConfiguration"
    ]
}
\endcode
See also: \l{ServerConfiguration}, \l{WebServerConfiguration}, \l{ServerConfiguration}
\section2 Configuration.GetMqttPolicies
Get all MQTT broker policies.
Params
\code
{}
\endcode
Returns
\code
{
    "mqttPolicies": [
        "$ref:MqttPolicy"
    ]
}
\endcode
See also: \l{MqttPolicy}
\section2 Configuration.GetMqttServerConfigurations
Get all MQTT Server configurations.
Params
\code
{}
\endcode
Returns
\code
{
    "mqttServerConfigurations": [
        "$ref:ServerConfiguration"
    ]
}
\endcode
See also: \l{ServerConfiguration}
\section2 Configuration.GetTimeZones
Get the list of available timezones.
Params
\code
{}
\endcode
Returns
\code
{
    "timeZones": [
        "String"
    ]
}
\endcode

\section2 Configuration.SetCloudEnabled
Sets whether the cloud connection is enabled or disabled in the settings.
Params
\code
{
    "enabled": "Bool"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.SetDebugServerEnabled
Enable or disable the debug server.
Params
\code
{
    "enabled": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.SetLanguage
DEPRECATED - Use the locale property in the Handshake message instead - Sets the server language to the given language. See also: "GetAvailableLanguages"
Params
\code
{
    "language": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.SetMqttPolicy
Configure a MQTT broker policy. If the ID is an existing one, the existing policy will be modified, otherwise a new one will be added.
Params
\code
{
    "policy": "$ref:MqttPolicy"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}, \l{MqttPolicy}
\section2 Configuration.SetMqttServerConfiguration
Configure a MQTT Server interface on the MQTT broker. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added. Setting authenticationEnabled to true will require MQTT clients to use credentials set in the MQTT broker policies.
Params
\code
{
    "configuration": "$ref:ServerConfiguration"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}, \l{ServerConfiguration}
\section2 Configuration.SetServerName
Set the name of the server. Default is nymea.
Params
\code
{
    "serverName": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.SetTcpServerConfiguration
Configure a TCP interface of the server. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added. Note: if you are changing the configuration for the interface you are currently connected to, the connection will be dropped.
Params
\code
{
    "configuration": "$ref:ServerConfiguration"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}, \l{ServerConfiguration}
\section2 Configuration.SetTimeZone
Set the time zone of the server. See also: "GetTimeZones"
Params
\code
{
    "timeZone": "String"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}
\section2 Configuration.SetWebServerConfiguration
Configure a WebServer interface of the server. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added.
Params
\code
{
    "configuration": "$ref:WebServerConfiguration"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}, \l{WebServerConfiguration}
\section2 Configuration.SetWebSocketServerConfiguration
Configure a WebSocket Server interface of the server. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added. Note: if you are changing the configuration for the interface you are currently connected to, the connection will be dropped.
Params
\code
{
    "configuration": "$ref:ServerConfiguration"
}
\endcode
Returns
\code
{
    "configurationError": "$ref:ConfigurationError"
}
\endcode
See also: \l{ConfigurationError}, \l{ServerConfiguration}
\section2 Devices.AddConfiguredDevice
Add a configured device with a setupMethod of SetupMethodJustAdd. For devices with a setupMethod different than SetupMethodJustAdd, use PairDevice. Devices with CreateMethodJustAdd require all parameters to be supplied here. Devices with CreateMethodDiscovery require the use of a deviceDescriptorId. For discovered devices params are not required and will be taken from the DeviceDescriptor, however, they may be overridden by supplying parameters here.
Params
\code
{
    "thingClassId": "Uuid", 
    "name": "String", 
    "o:deviceDescriptorId": "Uuid", 
    "o:deviceParams": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:deviceId": "Uuid", 
    "o:displayMessage": "String"
}
\endcode
See also: \l{DeviceError}, \l{Param}
\section2 Devices.BrowseDevice
Browse a device. If a DeviceClass indicates a device is browsable, this method will return the BrowserItems. If no parameter besides the deviceId is used, the root node of this device will be returned. Any returned item which is browsable can be passed as node. Results will be children of the given node.
Params
\code
{
    "deviceId": "Uuid", 
    "o:itemId": "String"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "items": [
        "$ref:BrowserItem"
    ]
}
\endcode
See also: \l{BrowserItem}, \l{DeviceError}
\section2 Devices.ConfirmPairing
Confirm an ongoing pairing. For SetupMethodUserAndPassword, provide the username in the "username" field and the password in the "secret" field. For SetupMethodEnterPin and provide the PIN in the "secret" field. For SetupMethodOAuth, return the entire unmodified callback URL containing the code parameter back in the secret field.
Params
\code
{
    "o:secret": "String", 
    "o:username": "String", 
    "pairingTransactionId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:deviceId": "Uuid", 
    "o:displayMessage": "String"
}
\endcode
See also: \l{DeviceError}
\section2 Devices.EditDevice
Edit the name of a device. This method does not change the configuration of the device.
Params
\code
{
    "deviceId": "Uuid", 
    "name": "String"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError"
}
\endcode
See also: \l{DeviceError}
\section2 Devices.GetActionTypes
Get action types for a specified thingClassId.
Params
\code
{
    "thingClassId": "Uuid"
}
\endcode
Returns
\code
{
    "actionTypes": [
        "$ref:ActionType"
    ]
}
\endcode
See also: \l{ActionType}
\section2 Devices.GetBrowserItem
Get a single item from the browser. This won't give any more info on an item than a regular browseDevice call, but it allows to fetch details of an item if only the ID is known.
Params
\code
{
    "deviceId": "Uuid", 
    "o:itemId": "String"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:item": "$ref:BrowserItem"
}
\endcode
See also: \l{BrowserItem}, \l{DeviceError}
\section2 Devices.GetConfiguredDevices
Returns a list of configured devices, optionally filtered by deviceId.
Params
\code
{
    "o:deviceId": "Uuid"
}
\endcode
Returns
\code
{
    "devices": [
        "$ref:Device"
    ]
}
\endcode
See also: \l{Device}
\section2 Devices.GetDiscoveredDevices
Performs a device discovery and returns the results. This function may take a while to return. Note that this method will include all the found devices, that is, including devices that may already have been added. Those devices will have deviceId set to the device id of the already added device. Such results may be used to reconfigure existing devices and might be filtered in cases where only unknown devices are of interest.
Params
\code
{
    "thingClassId": "Uuid", 
    "o:discoveryParams": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:deviceDescriptors": [
        "$ref:DeviceDescriptor"
    ], 
    "o:displayMessage": "String"
}
\endcode
See also: \l{DeviceDescriptor}, \l{DeviceError}, \l{Param}
\section2 Devices.GetEventTypes
Get event types for a specified thingClassId.
Params
\code
{
    "thingClassId": "Uuid"
}
\endcode
Returns
\code
{
    "eventTypes": [
        "$ref:EventType"
    ]
}
\endcode
See also: \l{EventType}
\section2 Devices.GetPluginConfiguration
Get a plugin's params.
Params
\code
{
    "pluginId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:configuration": [
        "$ref:Param"
    ]
}
\endcode
See also: \l{Param}, \l{DeviceError}
\section2 Devices.GetPlugins
Returns a list of loaded plugins.
Params
\code
{}
\endcode
Returns
\code
{
    "plugins": [
        "$ref:Plugin"
    ]
}
\endcode
See also: \l{Plugin}
\section2 Devices.GetStateTypes
Get state types for a specified thingClassId.
Params
\code
{
    "thingClassId": "Uuid"
}
\endcode
Returns
\code
{
    "stateTypes": [
        "$ref:StateType"
    ]
}
\endcode
See also: \l{StateType}
\section2 Devices.GetStateValue
Get the value of the given device and the given stateType
Params
\code
{
    "deviceId": "Uuid", 
    "stateTypeId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:value": "Variant"
}
\endcode
See also: \l{DeviceError}
\section2 Devices.GetStateValues
Get all the state values of the given device.
Params
\code
{
    "deviceId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:values": [
        {
            "stateTypeId": "Uuid", 
            "value": "Variant"
        }
    ]
}
\endcode
See also: \l{DeviceError}
\section2 Devices.GetSupportedDevices
Returns a list of supported Device classes, optionally filtered by vendorId.
Params
\code
{
    "o:vendorId": "Uuid"
}
\endcode
Returns
\code
{
    "thingClasses": [
        "$ref:DeviceClass"
    ]
}
\endcode
See also: \l{DeviceClass}
\section2 Devices.GetSupportedVendors
Returns a list of supported Vendors.
Params
\code
{}
\endcode
Returns
\code
{
    "vendors": [
        "$ref:Vendor"
    ]
}
\endcode
See also: \l{Vendor}
\section2 Devices.PairDevice
Pair a device. Use this for DeviceClasses with a setupMethod different than SetupMethodJustAdd. Use deviceDescriptorId or deviceParams, depending on the createMethod of the device class. CreateMethodJustAdd takes the parameters you want to have with that device. CreateMethodDiscovery requires the use of a deviceDescriptorId, optionally, parameters can be overridden here. If success is true, the return values will contain a pairingTransactionId, a displayMessage and the setupMethod. Depending on the setupMethod you should either proceed with AddConfiguredDevice or PairDevice.
Params
\code
{
    "thingClassId": "Uuid", 
    "name": "String", 
    "o:deviceDescriptorId": "Uuid", 
    "o:deviceParams": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:displayMessage": "String", 
    "o:oAuthUrl": "String", 
    "o:pairingTransactionId": "Uuid", 
    "o:setupMethod": "$ref:SetupMethod"
}
\endcode
See also: \l{SetupMethod}, \l{DeviceError}, \l{Param}
\section2 Devices.ReconfigureDevice
Edit the parameter configuration of the device. The device params will be set to the passed parameters and the setup device will be called. If the device is discoverable, you can perform a GetDiscoveredDevices before calling this method and pass the new DeviceDescriptor (rediscover). Only writable parameters can be changed. By default, every Param is writable.
Params
\code
{
    "deviceId": "Uuid", 
    "o:deviceDescriptorId": "Uuid", 
    "o:deviceParams": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:displayMessage": "String"
}
\endcode
See also: \l{DeviceError}, \l{Param}
\section2 Devices.RemoveConfiguredDevice
Remove a device from the system.
Params
\code
{
    "deviceId": "Uuid", 
    "o:removePolicy": "$ref:RemovePolicy", 
    "o:removePolicyList": [
        {
            "policy": "$ref:RemovePolicy", 
            "ruleId": "Uuid"
        }
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:ruleIds": [
        "Uuid"
    ]
}
\endcode
See also: \l{DeviceError}, \l{RemovePolicy}, \l{RemovePolicy}
\section2 Devices.SetDeviceSettings
Change the settings of a device.
Params
\code
{
    "deviceId": "Uuid", 
    "settings": [
        "$ref:Param"
    ]
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError"
}
\endcode
See also: \l{DeviceError}, \l{Param}
\section2 Devices.SetPluginConfiguration
Set a plugin's params.
Params
\code
{
    "configuration": [
        "$ref:Param"
    ], 
    "pluginId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError"
}
\endcode
See also: \l{DeviceError}, \l{Param}
\section2 Events.GetEventType
Get the EventType for the given eventTypeId.
Params
\code
{
    "eventTypeId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:eventType": "$ref:EventType"
}
\endcode
See also: \l{EventType}, \l{DeviceError}
\section2 JSONRPC.Authenticate
Authenticate a client to the api via user & password challenge. Provide a device name which allows the user to identify the client and revoke the token in case the device is lost or stolen. This will return a new token to be used to authorize a client at the API.
Params
\code
{
    "deviceName": "String", 
    "password": "String", 
    "username": "String"
}
\endcode
Returns
\code
{
    "o:token": "String", 
    "success": "Bool"
}
\endcode

\section2 JSONRPC.CreateUser
Create a new user in the API. Currently this is only allowed to be called once when a new nymea instance is set up. Call Authenticate after this to obtain a device token for this user.
Params
\code
{
    "password": "String", 
    "username": "String"
}
\endcode
Returns
\code
{
    "error": "$ref:UserError"
}
\endcode
See also: \l{UserError}
\section2 JSONRPC.Hello
Initiates a connection. Use this method to perform an initial handshake of the connection. Optionally, a parameter "locale" is can be passed to set up the used locale for this connection. Strings such as DeviceClass displayNames etc will be localized to this locale. If this parameter is omitted, the default system locale (depending on the configuration) is used. The reply of this method contains information about this core instance such as version information, uuid and its name. The locale valueindicates the locale used for this connection. Note: This method can be called multiple times. The locale used in the last call for this connection will be used. Other values, like initialSetupRequired might change if the setup has been performed in the meantime.
Params
\code
{
    "o:locale": "String"
}
\endcode
Returns
\code
{
    "authenticationRequired": "Bool", 
    "initialSetupRequired": "Bool", 
    "language": "String", 
    "locale": "String", 
    "name": "String", 
    "protocol version": "String", 
    "pushButtonAuthAvailable": "Bool", 
    "server": "String", 
    "uuid": "Uuid", 
    "version": "String"
}
\endcode

\section2 JSONRPC.Introspect
Introspect this API.
Params
\code
{}
\endcode
Returns
\code
{
    "methods": "Object", 
    "notifications": "Object", 
    "types": "Object"
}
\endcode

\section2 JSONRPC.IsCloudConnected
Check whether the cloud is currently connected. "connected" will be true whenever connectionState equals CloudConnectionStateConnected and is deprecated. Please use the connectionState value instead.
Params
\code
{}
\endcode
Returns
\code
{
    "connected": "Bool", 
    "connectionState": "$ref:CloudConnectionState"
}
\endcode
See also: \l{CloudConnectionState}
\section2 JSONRPC.KeepAlive
This is basically a Ping/Pong mechanism a client app may use to check server connectivity. Currently, the server does not actually do anything with this information and will return the call providing the given sessionId back to the caller. It is up to the client whether to use this or not and not required by the server to keep the connection alive.
Params
\code
{
    "sessionId": "String"
}
\endcode
Returns
\code
{
    "sessionId": "String", 
    "success": "Bool"
}
\endcode

\section2 JSONRPC.RemoveToken
Revoke access for a given token.
Params
\code
{
    "tokenId": "Uuid"
}
\endcode
Returns
\code
{
    "error": "$ref:UserError"
}
\endcode
See also: \l{UserError}
\section2 JSONRPC.RequestPushButtonAuth
Authenticate a client to the api via Push Button method. Provide a device name which allows the user to identify the client and revoke the token in case the device is lost or stolen. If push button hardware is available, this will return with success and start listening for push button presses. When the push button is pressed, the PushButtonAuthFinished notification will be sent to the requesting client. The procedure will be cancelled when the connection is interrupted. If another client requests push button authentication while a procedure is still going on, the second call will take over and the first one will be notified by the PushButtonAuthFinished signal about the error. The application should make it clear to the user to not press the button when the procedure fails as this can happen for 2 reasons: a) a second user is trying to auth at the same time and only the currently active user should press the button or b) it might indicate an attacker trying to take over and snooping in for tokens.
Params
\code
{
    "deviceName": "String"
}
\endcode
Returns
\code
{
    "success": "Bool", 
    "transactionId": "Int"
}
\endcode

\section2 JSONRPC.SetNotificationStatus
Enable/Disable notifications for this connections. Either "enabled" or "namespaces" needs to be given but not both of them. The boolean based "enabled" parameter will enable/disable all notifications at once. If instead the list-based "namespaces" parameter is provided, all given namespaceswill be enabled, the others will be disabled. The return value of "success" will indicate success of the operation. The "enabled" property in the return value is deprecated and used for legacy compatibilty only. It will be set to true if at least one namespace has been enabled.
Params
\code
{
    "o:enabled": "Bool", 
    "o:namespaces": [
        "$ref:Namespace"
    ]
}
\endcode
Returns
\code
{
    "enabled": "Bool", 
    "namespaces": [
        "$ref:Namespace"
    ]
}
\endcode
See also: \l{Namespace}, \l{Namespace}
\section2 JSONRPC.SetupCloudConnection
Sets up the cloud connection by deploying a certificate and its configuration.
Params
\code
{
    "certificatePEM": "String", 
    "endpoint": "String", 
    "privateKey": "String", 
    "publicKey": "String", 
    "rootCA": "String"
}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 JSONRPC.SetupRemoteAccess
Setup the remote connection by providing AWS token information. This requires the cloud to be connected.
Params
\code
{
    "idToken": "String", 
    "userId": "String"
}
\endcode
Returns
\code
{
    "message": "String", 
    "status": "Int"
}
\endcode

\section2 JSONRPC.Tokens
Return a list of TokenInfo objects of all the tokens for the current user.
Params
\code
{}
\endcode
Returns
\code
{
    "tokenInfoList": [
        "$ref:TokenInfo"
    ]
}
\endcode
See also: \l{TokenInfo}
\section2 JSONRPC.Version
Version of this nymea/JSONRPC interface.
Params
\code
{}
\endcode
Returns
\code
{
    "protocol version": "String", 
    "version": "String"
}
\endcode

\section2 Logging.GetLogEntries
Get the LogEntries matching the given filter. The result set will contain entries matching all filter rules combined. If multiple options are given for a single filter type, the result set will contain entries matching any of those. The offset starts at the newest entry in the result set. By default all items are returned. Example: If the specified filter returns a total amount of 100 entries:
- a offset value of 10 would include the oldest 90 entries
- a offset value of 0 would return all 100 entries

The offset is particularly useful in combination with the maxCount property and can be used for pagination. E.g. A result set of 10000 entries can be fetched in  batches of 1000 entries by fetching
1) offset 0, maxCount 1000: Entries 0 to 9999
2) offset 10000, maxCount 1000: Entries 10000 - 19999
3) offset 20000, maxCount 1000: Entries 20000 - 29999
...
Params
\code
{
    "o:deviceIds": [
        "Uuid"
    ], 
    "o:eventTypes": [
        "$ref:LoggingEventType"
    ], 
    "o:limit": "Int", 
    "o:loggingLevels": [
        "$ref:LoggingLevel"
    ], 
    "o:loggingSources": [
        "$ref:LoggingSource"
    ], 
    "o:offset": "Int", 
    "o:timeFilters": [
        {
            "o:endDate": "Int", 
            "o:startDate": "Int"
        }
    ], 
    "o:typeIds": [
        "Uuid"
    ], 
    "o:values": [
        "Variant"
    ]
}
\endcode
Returns
\code
{
    "count": "Int", 
    "loggingError": "$ref:LoggingError", 
    "o:logEntries": [
        "$ref:LogEntry"
    ], 
    "offset": "Int"
}
\endcode
See also: \l{LogEntry}, \l{LoggingError}, \l{LoggingLevel}, \l{LoggingEventType}, \l{LoggingSource}
\section2 NetworkManager.ConnectWifiNetwork
Connect to the wifi network with the given ssid and password.
Params
\code
{
    "interface": "String", 
    "o:password": "String", 
    "ssid": "String"
}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError"
}
\endcode
See also: \l{NetworkManagerError}
\section2 NetworkManager.DisconnectInterface
Disconnect the given network interface. The interface will remain disconnected until the user connect it again.
Params
\code
{
    "interface": "String"
}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError"
}
\endcode
See also: \l{NetworkManagerError}
\section2 NetworkManager.EnableNetworking
Enable or disable networking in the NetworkManager.
Params
\code
{
    "enable": "Bool"
}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError"
}
\endcode
See also: \l{NetworkManagerError}
\section2 NetworkManager.EnableWirelessNetworking
Enable or disable wireless networking in the NetworkManager.
Params
\code
{
    "enable": "Bool"
}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError"
}
\endcode
See also: \l{NetworkManagerError}
\section2 NetworkManager.GetNetworkDevices
Get the list of current network devices.
Params
\code
{}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError", 
    "wiredNetworkDevices": [
        "$ref:WiredNetworkDevice"
    ], 
    "wirelessNetworkDevices": [
        "$ref:WirelessNetworkDevice"
    ]
}
\endcode
See also: \l{NetworkManagerError}, \l{WiredNetworkDevice}, \l{WirelessNetworkDevice}
\section2 NetworkManager.GetNetworkStatus
Get the current network manager status.
Params
\code
{}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError", 
    "o:status": {
        "networkingEnabled": "Bool", 
        "state": "$ref:NetworkManagerState", 
        "wirelessNetworkingEnabled": "Bool"
    }
}
\endcode
See also: \l{NetworkManagerError}, \l{NetworkManagerState}
\section2 NetworkManager.GetWirelessAccessPoints
Get the current list of wireless network access points for the given interface. The interface has to be a WirelessNetworkDevice.
Params
\code
{
    "interface": "String"
}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError", 
    "o:wirelessAccessPoints": [
        "$ref:WirelessAccessPoint"
    ]
}
\endcode
See also: \l{NetworkManagerError}, \l{WirelessAccessPoint}
\section2 NetworkManager.ScanWifiNetworks
Start a wifi scan for searching new networks.
Params
\code
{
    "interface": "String"
}
\endcode
Returns
\code
{
    "networkManagerError": "$ref:NetworkManagerError"
}
\endcode
See also: \l{NetworkManagerError}
\section2 Rules.AddRule
Add a rule. You can describe rules by one or many EventDesciptors and a StateEvaluator. Note that only one of either eventDescriptor or eventDescriptorList may be passed at a time. A rule can be created but left disabled, meaning it won't actually be executed until set to enabled. If not given, enabled defaults to true. A rule can have a list of actions and exitActions. It must have at least one Action. For state based rules, actions will be executed when the system enters a state matching the stateDescriptor. The exitActions will be executed when the system leaves the described state again. For event based rules, actions will be executed when a matching event happens and if the stateEvaluator matches the system's state. ExitActions for such rules will be executed when a matching event happens and the stateEvaluator is not matching the system's state. A rule marked as executable can be executed via the API using Rules.ExecuteRule, that means, its actions will be executed regardless of the eventDescriptor and stateEvaluators.
Params
\code
{
    "actions": [
        "$ref:RuleAction"
    ], 
    "name": "String", 
    "o:enabled": "Bool", 
    "o:eventDescriptors": [
        "$ref:EventDescriptor"
    ], 
    "o:executable": "Bool", 
    "o:exitActions": [
        "$ref:RuleAction"
    ], 
    "o:stateEvaluator": "$ref:StateEvaluator", 
    "o:timeDescriptor": "$ref:TimeDescriptor"
}
\endcode
Returns
\code
{
    "o:ruleId": "Uuid", 
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}, \l{RuleAction}, \l{TimeDescriptor}, \l{RuleAction}, \l{EventDescriptor}, \l{StateEvaluator}
\section2 Rules.DisableRule
Disable a rule. The rule won't be triggered by it's events or state changes while it is disabled. If successful, the notification "Rule.RuleConfigurationChanged" will be emitted.
Params
\code
{
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}
\section2 Rules.EditRule
Edit the parameters of a rule. The configuration of the rule with the given ruleId will be replaced with the new given configuration. In ordert to enable or disable a Rule, please use the methods "Rules.EnableRule" and "Rules.DisableRule". If successful, the notification "Rule.RuleConfigurationChanged" will be emitted.
Params
\code
{
    "actions": [
        "$ref:RuleAction"
    ], 
    "name": "String", 
    "o:enabled": "Bool", 
    "o:eventDescriptors": [
        "$ref:EventDescriptor"
    ], 
    "o:executable": "Bool", 
    "o:exitActions": [
        "$ref:RuleAction"
    ], 
    "o:stateEvaluator": "$ref:StateEvaluator", 
    "o:timeDescriptor": "$ref:TimeDescriptor", 
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "o:rule": "$ref:Rule", 
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}, \l{Rule}, \l{RuleAction}, \l{TimeDescriptor}, \l{RuleAction}, \l{EventDescriptor}, \l{StateEvaluator}
\section2 Rules.EnableRule
Enabled a rule that has previously been disabled.If successful, the notification "Rule.RuleConfigurationChanged" will be emitted.
Params
\code
{
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}
\section2 Rules.ExecuteActions
Execute the action list of the rule with the given ruleId.
Params
\code
{
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}
\section2 Rules.ExecuteExitActions
Execute the exit action list of the rule with the given ruleId.
Params
\code
{
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}
\section2 Rules.FindRules
Find a list of rules containing any of the given parameters.
Params
\code
{
    "deviceId": "Uuid"
}
\endcode
Returns
\code
{
    "ruleIds": [
        "Uuid"
    ]
}
\endcode

\section2 Rules.GetRuleDetails
Get details for the rule identified by ruleId
Params
\code
{
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "o:rule": "$ref:Rule", 
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}, \l{Rule}
\section2 Rules.GetRules
Get the descriptions of all configured rules. If you need more information about a specific rule use the method Rules.GetRuleDetails.
Params
\code
{}
\endcode
Returns
\code
{
    "ruleDescriptions": [
        "$ref:RuleDescription"
    ]
}
\endcode
See also: \l{RuleDescription}
\section2 Rules.RemoveRule
Remove a rule
Params
\code
{
    "ruleId": "Uuid"
}
\endcode
Returns
\code
{
    "ruleError": "$ref:RuleError"
}
\endcode
See also: \l{RuleError}
\section2 States.GetStateType
Get the StateType for the given stateTypeId.
Params
\code
{
    "stateTypeId": "Uuid"
}
\endcode
Returns
\code
{
    "deviceError": "$ref:DeviceError", 
    "o:stateType": "$ref:StateType"
}
\endcode
See also: \l{StateType}, \l{DeviceError}
\section2 System.CheckForUpdates
Instruct the system to poll the server for updates. Normally the system should automatically do this in regular intervals, however, if the client wants to allow the user to manually check for new updates now, this can be called. Returns true if the operation has been started successfully and the update manager will become busy. In order to know whether there are updates available, clients should walk through the list of packages retrieved from GetPackages and check whether there are packages with the updateAvailable flag set to true.
Params
\code
{}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 System.EnableRepository
Enable or disable a repository.
Params
\code
{
    "enabled": "Bool", 
    "repositoryId": "String"
}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 System.GetCapabilities
Get the list of capabilites on this system. This allows reading whether things like rebooting or shutting down the system running nymea:core is supported on this host.
Params
\code
{}
\endcode
Returns
\code
{
    "powerManagement": "Bool", 
    "updateManagement": "Bool"
}
\endcode

\section2 System.GetPackages
Get the list of packages currently available to the system. This might include installed available but not installed packages. Installed packages will have the installedVersion set to a non-empty value.
Params
\code
{}
\endcode
Returns
\code
{
    "packages": [
        "$ref:Package"
    ]
}
\endcode
See also: \l{Package}
\section2 System.GetRepositories
Get the list of repositories currently available to the system.
Params
\code
{}
\endcode
Returns
\code
{
    "repositories": [
        "$ref:Repository"
    ]
}
\endcode
See also: \l{Repository}
\section2 System.GetUpdateStatus
Get the current status of the update system. "busy" indicates that the system is current busy with an operation regarding updates. This does not necessarily mean an actual update is running. When this is true, update related functions on the client should be marked as busy and no interaction with update components shall be allowed. An example for such a state is when the system queries the server if there are updates available, typically after a call to CheckForUpdates. "updateRunning" on the other hand indicates an actual update process is ongoing. The user should be informed about it, the system also might restart at any point while an update is running.
Params
\code
{}
\endcode
Returns
\code
{
    "busy": "Bool", 
    "updateRunning": "Bool"
}
\endcode

\section2 System.Reboot
Initiate a reboot of the system. The return value will indicate whether the procedure has been initiated successfully.
Params
\code
{}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 System.RemovePackages
Starts removing a package. Returns true if the removal has been started successfully. Before calling this method, clients should check whether the package can be removed (canRemove set to true).
Params
\code
{
    "packageIds": [
        "String"
    ]
}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 System.RollbackPackages
Starts a rollback. Returns true if the rollback has been started successfully. Before calling this method, clients should check whether the package can be rolled back (canRollback set to true).
Params
\code
{
    "packageIds": [
        "String"
    ]
}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 System.Shutdown
Initiate a shutdown of the system. The return value will indicate whether the procedure has been initiated successfully.
Params
\code
{}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 System.UpdatePackages
Starts updating/installing packages with the given ids. Returns true if the upgrade has been started successfully. Note that it might still fail later. Before calling this method, clients should check the packages whether they are in a state where they can either be installed (no installedVersion set) or upgraded (updateAvailable set to true).
Params
\code
{
    "o:packageIds": [
        "String"
    ]
}
\endcode
Returns
\code
{
    "success": "Bool"
}
\endcode

\section2 Tags.AddTag
Add a Tag. A Tag must have a deviceId OR a ruleId (call this method twice if you want to attach the same tag to a device and a rule), an appId (Use the appId of your app), a tagId (e.g. "favorites") and a value. Upon success, a TagAdded notification will be emitted. Calling this method twice for the same ids (device/rule, appId and tagId) but with a different value will update the tag's value and the TagValueChanged notification will be emitted.
Params
\code
{
    "tag": "$ref:Tag"
}
\endcode
Returns
\code
{
    "tagError": "$ref:TagError"
}
\endcode
See also: \l{TagError}, \l{Tag}
\section2 Tags.GetTags
Get the Tags matching the given filter. Tags can be filtered by a deviceID, a ruleId, an appId, a tagId or a combination of any (however, combining deviceId and ruleId will return an empty result set).
Params
\code
{
    "o:appId": "String", 
    "o:deviceId": "Uuid", 
    "o:ruleId": "Uuid", 
    "o:tagId": "String"
}
\endcode
Returns
\code
{
    "o:tags": [
        "$ref:Tag"
    ], 
    "tagError": "$ref:TagError"
}
\endcode
See also: \l{TagError}, \l{Tag}
\section2 Tags.RemoveTag
Remove a Tag. Tag value is optional and will be disregarded. If the ids match, the tag will be deleted and a TagRemoved notification will be emitted.
Params
\code
{
    "tag": "$ref:Tag"
}
\endcode
Returns
\code
{
    "tagError": "$ref:TagError"
}
\endcode
See also: \l{TagError}, \l{Tag}
\section1 Notifications
\section2 Configuration.BasicConfigurationChanged
Emitted whenever the basic configuration of this server changes.
Params
\code
{
    "basicConfiguration": {
        "debugServerEnabled": "Bool", 
        "language": "String", 
        "serverName": "String", 
        "serverTime": "Uint", 
        "serverUuid": "Uuid", 
        "timeZone": "String"
    }
}
\endcode

\section2 Configuration.CloudConfigurationChanged
Emitted whenever the cloud configuration is changed.
Params
\code
{
    "cloudConfiguration": {
        "enabled": "Bool"
    }
}
\endcode

\section2 Configuration.LanguageChanged
Emitted whenever the language of the server changed. The Plugins, Vendors and DeviceClasses have to be reloaded to get the translated data.
Params
\code
{
    "language": "String"
}
\endcode

\section2 Configuration.MqttPolicyChanged
Emitted whenever a MQTT broker policy is changed.
Params
\code
{
    "policy": "$ref:MqttPolicy"
}
\endcode
See also: \l{MqttPolicy}
\section2 Configuration.MqttPolicyRemoved
Emitted whenever a MQTT broker policy is removed.
Params
\code
{
    "clientId": "String"
}
\endcode

\section2 Configuration.MqttServerConfigurationChanged
Emitted whenever the MQTT broker configuration is changed.
Params
\code
{
    "mqttServerConfiguration": "$ref:ServerConfiguration"
}
\endcode
See also: \l{ServerConfiguration}
\section2 Configuration.MqttServerConfigurationRemoved
Emitted whenever a MQTT server configuration is removed.
Params
\code
{
    "id": "String"
}
\endcode

\section2 Configuration.TcpServerConfigurationChanged
Emitted whenever the TCP server configuration changes.
Params
\code
{
    "tcpServerConfiguration": "$ref:ServerConfiguration"
}
\endcode
See also: \l{ServerConfiguration}
\section2 Configuration.TcpServerConfigurationRemoved
Emitted whenever a TCP server configuration is removed.
Params
\code
{
    "id": "String"
}
\endcode

\section2 Configuration.WebServerConfigurationChanged
Emitted whenever the web server configuration changes.
Params
\code
{
    "webServerConfiguration": "$ref:WebServerConfiguration"
}
\endcode
See also: \l{WebServerConfiguration}
\section2 Configuration.WebServerConfigurationRemoved
Emitted whenever a Web server configuration is removed.
Params
\code
{
    "id": "String"
}
\endcode

\section2 Configuration.WebSocketServerConfigurationChanged
Emitted whenever the web socket server configuration changes.
Params
\code
{
    "webSocketServerConfiguration": "$ref:ServerConfiguration"
}
\endcode
See also: \l{ServerConfiguration}
\section2 Configuration.WebSocketServerConfigurationRemoved
Emitted whenever a WebSocket server configuration is removed.
Params
\code
{
    "id": "String"
}
\endcode

\section2 Devices.DeviceAdded
Emitted whenever a Device was added.
Params
\code
{
    "device": "$ref:Device"
}
\endcode
See also: \l{Device}
\section2 Devices.DeviceChanged
Emitted whenever the params or name of a Device are changed (by EditDevice or ReconfigureDevice).
Params
\code
{
    "device": "$ref:Device"
}
\endcode
See also: \l{Device}
\section2 Devices.DeviceRemoved
Emitted whenever a Device was removed.
Params
\code
{
    "deviceId": "Uuid"
}
\endcode

\section2 Devices.DeviceSettingChanged
Emitted whenever the setting of a Device is changed.
Params
\code
{
    "deviceId": "Uuid", 
    "paramTypeId": "Uuid", 
    "value": "Variant"
}
\endcode

\section2 Devices.PluginConfigurationChanged
Emitted whenever a plugin's configuration is changed.
Params
\code
{
    "configuration": [
        "$ref:Param"
    ], 
    "pluginId": "Uuid"
}
\endcode
See also: \l{Param}
\section2 Devices.StateChanged
Emitted whenever a State of a device changes.
Params
\code
{
    "deviceId": "Uuid", 
    "stateTypeId": "Uuid", 
    "value": "Variant"
}
\endcode

\section2 Events.EventTriggered
Emitted whenever an Event is triggered.
Params
\code
{
    "event": "$ref:Event"
}
\endcode
See also: \l{Event}
\section2 JSONRPC.CloudConnectedChanged
Emitted whenever the cloud connection status changes.
Params
\code
{
    "connected": "Bool", 
    "connectionState": "$ref:CloudConnectionState"
}
\endcode
See also: \l{CloudConnectionState}
\section2 JSONRPC.PushButtonAuthFinished
Emitted when a push button authentication reaches final state. NOTE: This notification is special. It will only be emitted to connections that did actively request a push button authentication, but also it will be emitted regardless of the notification settings. 
Params
\code
{
    "o:token": "String", 
    "success": "Bool", 
    "transactionId": "Int"
}
\endcode

\section2 Logging.LogDatabaseUpdated
Emitted whenever the database was updated. The database will be updated when a log entry was deleted. A log entry will be deleted when the corresponding device or a rule will be removed, or when the oldest entry of the database was deleted to keep to database in the size limits.
Params
\code
{}
\endcode

\section2 Logging.LogEntryAdded
Emitted whenever an entry is appended to the logging system. 
Params
\code
{
    "logEntry": "$ref:LogEntry"
}
\endcode
See also: \l{LogEntry}
\section2 NetworkManager.NetworkStatusChanged
Emitted whenever a status of a NetworkManager changes.
Params
\code
{
    "status": {
        "networkingEnabled": "Bool", 
        "state": "$ref:NetworkManagerState", 
        "wirelessNetworkingEnabled": "Bool"
    }
}
\endcode
See also: \l{NetworkManagerState}
\section2 NetworkManager.WiredNetworkDeviceAdded
Emitted whenever a new WiredNetworkDevice was added.
Params
\code
{
    "wiredNetworkDevice": "$ref:WiredNetworkDevice"
}
\endcode
See also: \l{WiredNetworkDevice}
\section2 NetworkManager.WiredNetworkDeviceChanged
Emitted whenever the given WiredNetworkDevice has changed.
Params
\code
{
    "wiredNetworkDevice": "$ref:WiredNetworkDevice"
}
\endcode
See also: \l{WiredNetworkDevice}
\section2 NetworkManager.WiredNetworkDeviceRemoved
Emitted whenever a WiredNetworkDevice was removed.
Params
\code
{
    "interface": "String"
}
\endcode

\section2 NetworkManager.WirelessNetworkDeviceAdded
Emitted whenever a new WirelessNetworkDevice was added.
Params
\code
{
    "wirelessNetworkDevice": "$ref:WirelessNetworkDevice"
}
\endcode
See also: \l{WirelessNetworkDevice}
\section2 NetworkManager.WirelessNetworkDeviceChanged
Emitted whenever the given WirelessNetworkDevice has changed.
Params
\code
{
    "wirelessNetworkDevice": "$ref:WirelessNetworkDevice"
}
\endcode
See also: \l{WirelessNetworkDevice}
\section2 NetworkManager.WirelessNetworkDeviceRemoved
Emitted whenever a WirelessNetworkDevice was removed.
Params
\code
{
    "interface": "String"
}
\endcode

\section2 Rules.RuleActiveChanged
Emitted whenever the active state of a Rule changed.
Params
\code
{
    "active": "Bool", 
    "ruleId": "Uuid"
}
\endcode

\section2 Rules.RuleAdded
Emitted whenever a Rule was added.
Params
\code
{
    "rule": "$ref:Rule"
}
\endcode
See also: \l{Rule}
\section2 Rules.RuleConfigurationChanged
Emitted whenever the configuration of a Rule changed.
Params
\code
{
    "rule": "$ref:Rule"
}
\endcode
See also: \l{Rule}
\section2 Rules.RuleRemoved
Emitted whenever a Rule was removed.
Params
\code
{
    "ruleId": "Uuid"
}
\endcode

\section2 System.CapabilitiesChanged
Emitted whenever the system capabilities change.
Params
\code
{
    "powerManagement": "Bool", 
    "updateManagement": "Bool"
}
\endcode

\section2 System.PackageAdded
Emitted whenever a package is added to the list of packages.
Params
\code
{
    "package": "$ref:Package"
}
\endcode
See also: \l{Package}
\section2 System.PackageChanged
Emitted whenever a package in the list of packages changes.
Params
\code
{
    "package": "$ref:Package"
}
\endcode
See also: \l{Package}
\section2 System.PackageRemoved
Emitted whenever a package is removed from the list of packages.
Params
\code
{
    "packageId": "String"
}
\endcode

\section2 System.RepositoryAdded
Emitted whenever a repository is added to the list of repositories.
Params
\code
{
    "repository": "$ref:Repository"
}
\endcode
See also: \l{Repository}
\section2 System.RepositoryChanged
Emitted whenever a repository in the list of repositories changes.
Params
\code
{
    "repository": "$ref:Repository"
}
\endcode
See also: \l{Repository}
\section2 System.RepositoryRemoved
Emitted whenever a repository is removed from the list of repositories.
Params
\code
{
    "repositoryId": "String"
}
\endcode

\section2 System.UpdateStatusChanged
Emitted whenever the update status changes.
Params
\code
{
    "busy": "Bool", 
    "updateRunning": "Bool"
}
\endcode

\section2 Tags.TagAdded
Emitted whenever a tag is added to the system. 
Params
\code
{
    "tag": "$ref:Tag"
}
\endcode
See also: \l{Tag}
\section2 Tags.TagRemoved
Emitted whenever a tag is removed from the system. 
Params
\code
{
    "tag": "$ref:Tag"
}
\endcode
See also: \l{Tag}
\section2 Tags.TagValueChanged
Emitted whenever a tag's value is changed in the system. 
Params
\code
{
    "tag": "$ref:Tag"
}
\endcode
See also: \l{Tag}
\section1 Full introspect
\code
{
    "methods": {
        "Actions.ExecuteAction": {
            "description": "Execute a single action.", 
            "params": {
                "actionTypeId": "Uuid", 
                "deviceId": "Uuid", 
                "o:params": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:displayMessage": "String"
            }
        }, 
        "Actions.ExecuteBrowserItem": {
            "description": "Execute the item identified by itemId on the given device.", 
            "params": {
                "deviceId": "Uuid", 
                "itemId": "String"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError"
            }
        }, 
        "Actions.ExecuteBrowserItemAction": {
            "description": "Execute the action for the browser item identified by actionTypeId and the itemId on the given device.", 
            "params": {
                "actionTypeId": "Uuid", 
                "deviceId": "Uuid", 
                "itemId": "String", 
                "o:params": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError"
            }
        }, 
        "Actions.GetActionType": {
            "description": "Get the ActionType for the given ActionTypeId", 
            "params": {
                "actionTypeId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:actionType": {
                    "displayName": "String", 
                    "id": "Uuid", 
                    "index": "Int", 
                    "name": "String", 
                    "paramTypes": [
                        "$ref:ParamType"
                    ]
                }
            }
        }, 
        "Configuration.DeleteMqttPolicy": {
            "description": "Delete a MQTT policy from the broker.", 
            "params": {
                "clientId": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.DeleteMqttServerConfiguration": {
            "description": "Delete a MQTT Server interface of the server.", 
            "params": {
                "id": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.DeleteTcpServerConfiguration": {
            "description": "Delete a TCP interface of the server. Note: if you are deleting the configuration for the interface you are currently connected to, the connection will be dropped.", 
            "params": {
                "id": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.DeleteWebServerConfiguration": {
            "description": "Delete a WebServer interface of the server.", 
            "params": {
                "id": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.DeleteWebSocketServerConfiguration": {
            "description": "Delete a WebSocket Server interface of the server. Note: if you are deleting the configuration for the interface you are currently connected to, the connection will be dropped.", 
            "params": {
                "id": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.GetAvailableLanguages": {
            "description": "DEPRECATED - Use the locale property in the Handshake message instead - Returns a list of locale codes available for the server. i.e. en_US, de_AT", 
            "params": {}, 
            "returns": {
                "languages": [
                    "String"
                ]
            }
        }, 
        "Configuration.GetConfigurations": {
            "description": "Get all configuration parameters of the server.", 
            "params": {}, 
            "returns": {
                "basicConfiguration": {
                    "debugServerEnabled": "Bool", 
                    "language": "String", 
                    "serverName": "String", 
                    "serverTime": "Uint", 
                    "serverUuid": "Uuid", 
                    "timeZone": "String"
                }, 
                "cloud": {
                    "enabled": "Bool"
                }, 
                "tcpServerConfigurations": [
                    "$ref:ServerConfiguration"
                ], 
                "webServerConfigurations": [
                    "$ref:WebServerConfiguration"
                ], 
                "webSocketServerConfigurations": [
                    "$ref:ServerConfiguration"
                ]
            }
        }, 
        "Configuration.GetMqttPolicies": {
            "description": "Get all MQTT broker policies.", 
            "params": {}, 
            "returns": {
                "mqttPolicies": [
                    "$ref:MqttPolicy"
                ]
            }
        }, 
        "Configuration.GetMqttServerConfigurations": {
            "description": "Get all MQTT Server configurations.", 
            "params": {}, 
            "returns": {
                "mqttServerConfigurations": [
                    "$ref:ServerConfiguration"
                ]
            }
        }, 
        "Configuration.GetTimeZones": {
            "description": "Get the list of available timezones.", 
            "params": {}, 
            "returns": {
                "timeZones": [
                    "String"
                ]
            }
        }, 
        "Configuration.SetCloudEnabled": {
            "description": "Sets whether the cloud connection is enabled or disabled in the settings.", 
            "params": {
                "enabled": "Bool"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetDebugServerEnabled": {
            "description": "Enable or disable the debug server.", 
            "params": {
                "enabled": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetLanguage": {
            "description": "DEPRECATED - Use the locale property in the Handshake message instead - Sets the server language to the given language. See also: \"GetAvailableLanguages\"", 
            "params": {
                "language": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetMqttPolicy": {
            "description": "Configure a MQTT broker policy. If the ID is an existing one, the existing policy will be modified, otherwise a new one will be added.", 
            "params": {
                "policy": "$ref:MqttPolicy"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetMqttServerConfiguration": {
            "description": "Configure a MQTT Server interface on the MQTT broker. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added. Setting authenticationEnabled to true will require MQTT clients to use credentials set in the MQTT broker policies.", 
            "params": {
                "configuration": "$ref:ServerConfiguration"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetServerName": {
            "description": "Set the name of the server. Default is nymea.", 
            "params": {
                "serverName": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetTcpServerConfiguration": {
            "description": "Configure a TCP interface of the server. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added. Note: if you are changing the configuration for the interface you are currently connected to, the connection will be dropped.", 
            "params": {
                "configuration": "$ref:ServerConfiguration"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetTimeZone": {
            "description": "Set the time zone of the server. See also: \"GetTimeZones\"", 
            "params": {
                "timeZone": "String"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetWebServerConfiguration": {
            "description": "Configure a WebServer interface of the server. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added.", 
            "params": {
                "configuration": "$ref:WebServerConfiguration"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Configuration.SetWebSocketServerConfiguration": {
            "description": "Configure a WebSocket Server interface of the server. If the ID is an existing one, the existing config will be modified, otherwise a new one will be added. Note: if you are changing the configuration for the interface you are currently connected to, the connection will be dropped.", 
            "params": {
                "configuration": "$ref:ServerConfiguration"
            }, 
            "returns": {
                "configurationError": "$ref:ConfigurationError"
            }
        }, 
        "Devices.AddConfiguredDevice": {
            "description": "Add a configured device with a setupMethod of SetupMethodJustAdd. For devices with a setupMethod different than SetupMethodJustAdd, use PairDevice. Devices with CreateMethodJustAdd require all parameters to be supplied here. Devices with CreateMethodDiscovery require the use of a deviceDescriptorId. For discovered devices params are not required and will be taken from the DeviceDescriptor, however, they may be overridden by supplying parameters here.", 
            "params": {
                "thingClassId": "Uuid", 
                "name": "String", 
                "o:deviceDescriptorId": "Uuid", 
                "o:deviceParams": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:deviceId": "Uuid", 
                "o:displayMessage": "String"
            }
        }, 
        "Devices.BrowseDevice": {
            "description": "Browse a device. If a DeviceClass indicates a device is browsable, this method will return the BrowserItems. If no parameter besides the deviceId is used, the root node of this device will be returned. Any returned item which is browsable can be passed as node. Results will be children of the given node.", 
            "params": {
                "deviceId": "Uuid", 
                "o:itemId": "String"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "items": [
                    "$ref:BrowserItem"
                ]
            }
        }, 
        "Devices.ConfirmPairing": {
            "description": "Confirm an ongoing pairing. For SetupMethodUserAndPassword, provide the username in the \"username\" field and the password in the \"secret\" field. For SetupMethodEnterPin and provide the PIN in the \"secret\" field. For SetupMethodOAuth, return the entire unmodified callback URL containing the code parameter back in the secret field.", 
            "params": {
                "o:secret": "String", 
                "o:username": "String", 
                "pairingTransactionId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:deviceId": "Uuid", 
                "o:displayMessage": "String"
            }
        }, 
        "Devices.EditDevice": {
            "description": "Edit the name of a device. This method does not change the configuration of the device.", 
            "params": {
                "deviceId": "Uuid", 
                "name": "String"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError"
            }
        }, 
        "Devices.GetActionTypes": {
            "description": "Get action types for a specified thingClassId.", 
            "params": {
                "thingClassId": "Uuid"
            }, 
            "returns": {
                "actionTypes": [
                    "$ref:ActionType"
                ]
            }
        }, 
        "Devices.GetBrowserItem": {
            "description": "Get a single item from the browser. This won't give any more info on an item than a regular browseDevice call, but it allows to fetch details of an item if only the ID is known.", 
            "params": {
                "deviceId": "Uuid", 
                "o:itemId": "String"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:item": "$ref:BrowserItem"
            }
        }, 
        "Devices.GetConfiguredDevices": {
            "description": "Returns a list of configured devices, optionally filtered by deviceId.", 
            "params": {
                "o:deviceId": "Uuid"
            }, 
            "returns": {
                "devices": [
                    "$ref:Device"
                ]
            }
        }, 
        "Devices.GetDiscoveredDevices": {
            "description": "Performs a device discovery and returns the results. This function may take a while to return. Note that this method will include all the found devices, that is, including devices that may already have been added. Those devices will have deviceId set to the device id of the already added device. Such results may be used to reconfigure existing devices and might be filtered in cases where only unknown devices are of interest.", 
            "params": {
                "thingClassId": "Uuid", 
                "o:discoveryParams": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:deviceDescriptors": [
                    "$ref:DeviceDescriptor"
                ], 
                "o:displayMessage": "String"
            }
        }, 
        "Devices.GetEventTypes": {
            "description": "Get event types for a specified thingClassId.", 
            "params": {
                "thingClassId": "Uuid"
            }, 
            "returns": {
                "eventTypes": [
                    "$ref:EventType"
                ]
            }
        }, 
        "Devices.GetPluginConfiguration": {
            "description": "Get a plugin's params.", 
            "params": {
                "pluginId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:configuration": [
                    "$ref:Param"
                ]
            }
        }, 
        "Devices.GetPlugins": {
            "description": "Returns a list of loaded plugins.", 
            "params": {}, 
            "returns": {
                "plugins": [
                    "$ref:Plugin"
                ]
            }
        }, 
        "Devices.GetStateTypes": {
            "description": "Get state types for a specified thingClassId.", 
            "params": {
                "thingClassId": "Uuid"
            }, 
            "returns": {
                "stateTypes": [
                    "$ref:StateType"
                ]
            }
        }, 
        "Devices.GetStateValue": {
            "description": "Get the value of the given device and the given stateType", 
            "params": {
                "deviceId": "Uuid", 
                "stateTypeId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:value": "Variant"
            }
        }, 
        "Devices.GetStateValues": {
            "description": "Get all the state values of the given device.", 
            "params": {
                "deviceId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:values": [
                    {
                        "stateTypeId": "Uuid", 
                        "value": "Variant"
                    }
                ]
            }
        }, 
        "Devices.GetSupportedDevices": {
            "description": "Returns a list of supported Device classes, optionally filtered by vendorId.", 
            "params": {
                "o:vendorId": "Uuid"
            }, 
            "returns": {
                "thingClasses": [
                    "$ref:DeviceClass"
                ]
            }
        }, 
        "Devices.GetSupportedVendors": {
            "description": "Returns a list of supported Vendors.", 
            "params": {}, 
            "returns": {
                "vendors": [
                    "$ref:Vendor"
                ]
            }
        }, 
        "Devices.PairDevice": {
            "description": "Pair a device. Use this for DeviceClasses with a setupMethod different than SetupMethodJustAdd. Use deviceDescriptorId or deviceParams, depending on the createMethod of the device class. CreateMethodJustAdd takes the parameters you want to have with that device. CreateMethodDiscovery requires the use of a deviceDescriptorId, optionally, parameters can be overridden here. If success is true, the return values will contain a pairingTransactionId, a displayMessage and the setupMethod. Depending on the setupMethod you should either proceed with AddConfiguredDevice or PairDevice.", 
            "params": {
                "thingClassId": "Uuid", 
                "name": "String", 
                "o:deviceDescriptorId": "Uuid", 
                "o:deviceParams": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:displayMessage": "String", 
                "o:oAuthUrl": "String", 
                "o:pairingTransactionId": "Uuid", 
                "o:setupMethod": "$ref:SetupMethod"
            }
        }, 
        "Devices.ReconfigureDevice": {
            "description": "Edit the parameter configuration of the device. The device params will be set to the passed parameters and the setup device will be called. If the device is discoverable, you can perform a GetDiscoveredDevices before calling this method and pass the new DeviceDescriptor (rediscover). Only writable parameters can be changed. By default, every Param is writable.", 
            "params": {
                "deviceId": "Uuid", 
                "o:deviceDescriptorId": "Uuid", 
                "o:deviceParams": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:displayMessage": "String"
            }
        }, 
        "Devices.RemoveConfiguredDevice": {
            "description": "Remove a device from the system.", 
            "params": {
                "deviceId": "Uuid", 
                "o:removePolicy": "$ref:RemovePolicy", 
                "o:removePolicyList": [
                    {
                        "policy": "$ref:RemovePolicy", 
                        "ruleId": "Uuid"
                    }
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:ruleIds": [
                    "Uuid"
                ]
            }
        }, 
        "Devices.SetDeviceSettings": {
            "description": "Change the settings of a device.", 
            "params": {
                "deviceId": "Uuid", 
                "settings": [
                    "$ref:Param"
                ]
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError"
            }
        }, 
        "Devices.SetPluginConfiguration": {
            "description": "Set a plugin's params.", 
            "params": {
                "configuration": [
                    "$ref:Param"
                ], 
                "pluginId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError"
            }
        }, 
        "Events.GetEventType": {
            "description": "Get the EventType for the given eventTypeId.", 
            "params": {
                "eventTypeId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:eventType": "$ref:EventType"
            }
        }, 
        "JSONRPC.Authenticate": {
            "description": "Authenticate a client to the api via user & password challenge. Provide a device name which allows the user to identify the client and revoke the token in case the device is lost or stolen. This will return a new token to be used to authorize a client at the API.", 
            "params": {
                "deviceName": "String", 
                "password": "String", 
                "username": "String"
            }, 
            "returns": {
                "o:token": "String", 
                "success": "Bool"
            }
        }, 
        "JSONRPC.CreateUser": {
            "description": "Create a new user in the API. Currently this is only allowed to be called once when a new nymea instance is set up. Call Authenticate after this to obtain a device token for this user.", 
            "params": {
                "password": "String", 
                "username": "String"
            }, 
            "returns": {
                "error": "$ref:UserError"
            }
        }, 
        "JSONRPC.Hello": {
            "description": "Initiates a connection. Use this method to perform an initial handshake of the connection. Optionally, a parameter \"locale\" is can be passed to set up the used locale for this connection. Strings such as DeviceClass displayNames etc will be localized to this locale. If this parameter is omitted, the default system locale (depending on the configuration) is used. The reply of this method contains information about this core instance such as version information, uuid and its name. The locale valueindicates the locale used for this connection. Note: This method can be called multiple times. The locale used in the last call for this connection will be used. Other values, like initialSetupRequired might change if the setup has been performed in the meantime.", 
            "params": {
                "o:locale": "String"
            }, 
            "returns": {
                "authenticationRequired": "Bool", 
                "initialSetupRequired": "Bool", 
                "language": "String", 
                "locale": "String", 
                "name": "String", 
                "protocol version": "String", 
                "pushButtonAuthAvailable": "Bool", 
                "server": "String", 
                "uuid": "Uuid", 
                "version": "String"
            }
        }, 
        "JSONRPC.Introspect": {
            "description": "Introspect this API.", 
            "params": {}, 
            "returns": {
                "methods": "Object", 
                "notifications": "Object", 
                "types": "Object"
            }
        }, 
        "JSONRPC.IsCloudConnected": {
            "description": "Check whether the cloud is currently connected. \"connected\" will be true whenever connectionState equals CloudConnectionStateConnected and is deprecated. Please use the connectionState value instead.", 
            "params": {}, 
            "returns": {
                "connected": "Bool", 
                "connectionState": "$ref:CloudConnectionState"
            }
        }, 
        "JSONRPC.KeepAlive": {
            "description": "This is basically a Ping/Pong mechanism a client app may use to check server connectivity. Currently, the server does not actually do anything with this information and will return the call providing the given sessionId back to the caller. It is up to the client whether to use this or not and not required by the server to keep the connection alive.", 
            "params": {
                "sessionId": "String"
            }, 
            "returns": {
                "sessionId": "String", 
                "success": "Bool"
            }
        }, 
        "JSONRPC.RemoveToken": {
            "description": "Revoke access for a given token.", 
            "params": {
                "tokenId": "Uuid"
            }, 
            "returns": {
                "error": "$ref:UserError"
            }
        }, 
        "JSONRPC.RequestPushButtonAuth": {
            "description": "Authenticate a client to the api via Push Button method. Provide a device name which allows the user to identify the client and revoke the token in case the device is lost or stolen. If push button hardware is available, this will return with success and start listening for push button presses. When the push button is pressed, the PushButtonAuthFinished notification will be sent to the requesting client. The procedure will be cancelled when the connection is interrupted. If another client requests push button authentication while a procedure is still going on, the second call will take over and the first one will be notified by the PushButtonAuthFinished signal about the error. The application should make it clear to the user to not press the button when the procedure fails as this can happen for 2 reasons: a) a second user is trying to auth at the same time and only the currently active user should press the button or b) it might indicate an attacker trying to take over and snooping in for tokens.", 
            "params": {
                "deviceName": "String"
            }, 
            "returns": {
                "success": "Bool", 
                "transactionId": "Int"
            }
        }, 
        "JSONRPC.SetNotificationStatus": {
            "description": "Enable/Disable notifications for this connections. Either \"enabled\" or \"namespaces\" needs to be given but not both of them. The boolean based \"enabled\" parameter will enable/disable all notifications at once. If instead the list-based \"namespaces\" parameter is provided, all given namespaceswill be enabled, the others will be disabled. The return value of \"success\" will indicate success of the operation. The \"enabled\" property in the return value is deprecated and used for legacy compatibilty only. It will be set to true if at least one namespace has been enabled.", 
            "params": {
                "o:enabled": "Bool", 
                "o:namespaces": [
                    "$ref:Namespace"
                ]
            }, 
            "returns": {
                "enabled": "Bool", 
                "namespaces": [
                    "$ref:Namespace"
                ]
            }
        }, 
        "JSONRPC.SetupCloudConnection": {
            "description": "Sets up the cloud connection by deploying a certificate and its configuration.", 
            "params": {
                "certificatePEM": "String", 
                "endpoint": "String", 
                "privateKey": "String", 
                "publicKey": "String", 
                "rootCA": "String"
            }, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "JSONRPC.SetupRemoteAccess": {
            "description": "Setup the remote connection by providing AWS token information. This requires the cloud to be connected.", 
            "params": {
                "idToken": "String", 
                "userId": "String"
            }, 
            "returns": {
                "message": "String", 
                "status": "Int"
            }
        }, 
        "JSONRPC.Tokens": {
            "description": "Return a list of TokenInfo objects of all the tokens for the current user.", 
            "params": {}, 
            "returns": {
                "tokenInfoList": [
                    "$ref:TokenInfo"
                ]
            }
        }, 
        "JSONRPC.Version": {
            "description": "Version of this nymea/JSONRPC interface.", 
            "params": {}, 
            "returns": {
                "protocol version": "String", 
                "version": "String"
            }
        }, 
        "Logging.GetLogEntries": {
            "description": "Get the LogEntries matching the given filter. The result set will contain entries matching all filter rules combined. If multiple options are given for a single filter type, the result set will contain entries matching any of those. The offset starts at the newest entry in the result set. By default all items are returned. Example: If the specified filter returns a total amount of 100 entries:\n- a offset value of 10 would include the oldest 90 entries\n- a offset value of 0 would return all 100 entries\n\nThe offset is particularly useful in combination with the maxCount property and can be used for pagination. E.g. A result set of 10000 entries can be fetched in  batches of 1000 entries by fetching\n1) offset 0, maxCount 1000: Entries 0 to 9999\n2) offset 10000, maxCount 1000: Entries 10000 - 19999\n3) offset 20000, maxCount 1000: Entries 20000 - 29999\n...", 
            "params": {
                "o:deviceIds": [
                    "Uuid"
                ], 
                "o:eventTypes": [
                    "$ref:LoggingEventType"
                ], 
                "o:limit": "Int", 
                "o:loggingLevels": [
                    "$ref:LoggingLevel"
                ], 
                "o:loggingSources": [
                    "$ref:LoggingSource"
                ], 
                "o:offset": "Int", 
                "o:timeFilters": [
                    {
                        "o:endDate": "Int", 
                        "o:startDate": "Int"
                    }
                ], 
                "o:typeIds": [
                    "Uuid"
                ], 
                "o:values": [
                    "Variant"
                ]
            }, 
            "returns": {
                "count": "Int", 
                "loggingError": "$ref:LoggingError", 
                "o:logEntries": [
                    "$ref:LogEntry"
                ], 
                "offset": "Int"
            }
        }, 
        "NetworkManager.ConnectWifiNetwork": {
            "description": "Connect to the wifi network with the given ssid and password.", 
            "params": {
                "interface": "String", 
                "o:password": "String", 
                "ssid": "String"
            }, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError"
            }
        }, 
        "NetworkManager.DisconnectInterface": {
            "description": "Disconnect the given network interface. The interface will remain disconnected until the user connect it again.", 
            "params": {
                "interface": "String"
            }, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError"
            }
        }, 
        "NetworkManager.EnableNetworking": {
            "description": "Enable or disable networking in the NetworkManager.", 
            "params": {
                "enable": "Bool"
            }, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError"
            }
        }, 
        "NetworkManager.EnableWirelessNetworking": {
            "description": "Enable or disable wireless networking in the NetworkManager.", 
            "params": {
                "enable": "Bool"
            }, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError"
            }
        }, 
        "NetworkManager.GetNetworkDevices": {
            "description": "Get the list of current network devices.", 
            "params": {}, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError", 
                "wiredNetworkDevices": [
                    "$ref:WiredNetworkDevice"
                ], 
                "wirelessNetworkDevices": [
                    "$ref:WirelessNetworkDevice"
                ]
            }
        }, 
        "NetworkManager.GetNetworkStatus": {
            "description": "Get the current network manager status.", 
            "params": {}, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError", 
                "o:status": {
                    "networkingEnabled": "Bool", 
                    "state": "$ref:NetworkManagerState", 
                    "wirelessNetworkingEnabled": "Bool"
                }
            }
        }, 
        "NetworkManager.GetWirelessAccessPoints": {
            "description": "Get the current list of wireless network access points for the given interface. The interface has to be a WirelessNetworkDevice.", 
            "params": {
                "interface": "String"
            }, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError", 
                "o:wirelessAccessPoints": [
                    "$ref:WirelessAccessPoint"
                ]
            }
        }, 
        "NetworkManager.ScanWifiNetworks": {
            "description": "Start a wifi scan for searching new networks.", 
            "params": {
                "interface": "String"
            }, 
            "returns": {
                "networkManagerError": "$ref:NetworkManagerError"
            }
        }, 
        "Rules.AddRule": {
            "description": "Add a rule. You can describe rules by one or many EventDesciptors and a StateEvaluator. Note that only one of either eventDescriptor or eventDescriptorList may be passed at a time. A rule can be created but left disabled, meaning it won't actually be executed until set to enabled. If not given, enabled defaults to true. A rule can have a list of actions and exitActions. It must have at least one Action. For state based rules, actions will be executed when the system enters a state matching the stateDescriptor. The exitActions will be executed when the system leaves the described state again. For event based rules, actions will be executed when a matching event happens and if the stateEvaluator matches the system's state. ExitActions for such rules will be executed when a matching event happens and the stateEvaluator is not matching the system's state. A rule marked as executable can be executed via the API using Rules.ExecuteRule, that means, its actions will be executed regardless of the eventDescriptor and stateEvaluators.", 
            "params": {
                "actions": [
                    "$ref:RuleAction"
                ], 
                "name": "String", 
                "o:enabled": "Bool", 
                "o:eventDescriptors": [
                    "$ref:EventDescriptor"
                ], 
                "o:executable": "Bool", 
                "o:exitActions": [
                    "$ref:RuleAction"
                ], 
                "o:stateEvaluator": "$ref:StateEvaluator", 
                "o:timeDescriptor": "$ref:TimeDescriptor"
            }, 
            "returns": {
                "o:ruleId": "Uuid", 
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.DisableRule": {
            "description": "Disable a rule. The rule won't be triggered by it's events or state changes while it is disabled. If successful, the notification \"Rule.RuleConfigurationChanged\" will be emitted.", 
            "params": {
                "ruleId": "Uuid"
            }, 
            "returns": {
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.EditRule": {
            "description": "Edit the parameters of a rule. The configuration of the rule with the given ruleId will be replaced with the new given configuration. In ordert to enable or disable a Rule, please use the methods \"Rules.EnableRule\" and \"Rules.DisableRule\". If successful, the notification \"Rule.RuleConfigurationChanged\" will be emitted.", 
            "params": {
                "actions": [
                    "$ref:RuleAction"
                ], 
                "name": "String", 
                "o:enabled": "Bool", 
                "o:eventDescriptors": [
                    "$ref:EventDescriptor"
                ], 
                "o:executable": "Bool", 
                "o:exitActions": [
                    "$ref:RuleAction"
                ], 
                "o:stateEvaluator": "$ref:StateEvaluator", 
                "o:timeDescriptor": "$ref:TimeDescriptor", 
                "ruleId": "Uuid"
            }, 
            "returns": {
                "o:rule": "$ref:Rule", 
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.EnableRule": {
            "description": "Enabled a rule that has previously been disabled.If successful, the notification \"Rule.RuleConfigurationChanged\" will be emitted.", 
            "params": {
                "ruleId": "Uuid"
            }, 
            "returns": {
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.ExecuteActions": {
            "description": "Execute the action list of the rule with the given ruleId.", 
            "params": {
                "ruleId": "Uuid"
            }, 
            "returns": {
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.ExecuteExitActions": {
            "description": "Execute the exit action list of the rule with the given ruleId.", 
            "params": {
                "ruleId": "Uuid"
            }, 
            "returns": {
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.FindRules": {
            "description": "Find a list of rules containing any of the given parameters.", 
            "params": {
                "deviceId": "Uuid"
            }, 
            "returns": {
                "ruleIds": [
                    "Uuid"
                ]
            }
        }, 
        "Rules.GetRuleDetails": {
            "description": "Get details for the rule identified by ruleId", 
            "params": {
                "ruleId": "Uuid"
            }, 
            "returns": {
                "o:rule": "$ref:Rule", 
                "ruleError": "$ref:RuleError"
            }
        }, 
        "Rules.GetRules": {
            "description": "Get the descriptions of all configured rules. If you need more information about a specific rule use the method Rules.GetRuleDetails.", 
            "params": {}, 
            "returns": {
                "ruleDescriptions": [
                    "$ref:RuleDescription"
                ]
            }
        }, 
        "Rules.RemoveRule": {
            "description": "Remove a rule", 
            "params": {
                "ruleId": "Uuid"
            }, 
            "returns": {
                "ruleError": "$ref:RuleError"
            }
        }, 
        "States.GetStateType": {
            "description": "Get the StateType for the given stateTypeId.", 
            "params": {
                "stateTypeId": "Uuid"
            }, 
            "returns": {
                "deviceError": "$ref:DeviceError", 
                "o:stateType": "$ref:StateType"
            }
        }, 
        "System.CheckForUpdates": {
            "description": "Instruct the system to poll the server for updates. Normally the system should automatically do this in regular intervals, however, if the client wants to allow the user to manually check for new updates now, this can be called. Returns true if the operation has been started successfully and the update manager will become busy. In order to know whether there are updates available, clients should walk through the list of packages retrieved from GetPackages and check whether there are packages with the updateAvailable flag set to true.", 
            "params": {}, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "System.EnableRepository": {
            "description": "Enable or disable a repository.", 
            "params": {
                "enabled": "Bool", 
                "repositoryId": "String"
            }, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "System.GetCapabilities": {
            "description": "Get the list of capabilites on this system. This allows reading whether things like rebooting or shutting down the system running nymea:core is supported on this host.", 
            "params": {}, 
            "returns": {
                "powerManagement": "Bool", 
                "updateManagement": "Bool"
            }
        }, 
        "System.GetPackages": {
            "description": "Get the list of packages currently available to the system. This might include installed available but not installed packages. Installed packages will have the installedVersion set to a non-empty value.", 
            "params": {}, 
            "returns": {
                "packages": [
                    "$ref:Package"
                ]
            }
        }, 
        "System.GetRepositories": {
            "description": "Get the list of repositories currently available to the system.", 
            "params": {}, 
            "returns": {
                "repositories": [
                    "$ref:Repository"
                ]
            }
        }, 
        "System.GetUpdateStatus": {
            "description": "Get the current status of the update system. \"busy\" indicates that the system is current busy with an operation regarding updates. This does not necessarily mean an actual update is running. When this is true, update related functions on the client should be marked as busy and no interaction with update components shall be allowed. An example for such a state is when the system queries the server if there are updates available, typically after a call to CheckForUpdates. \"updateRunning\" on the other hand indicates an actual update process is ongoing. The user should be informed about it, the system also might restart at any point while an update is running.", 
            "params": {}, 
            "returns": {
                "busy": "Bool", 
                "updateRunning": "Bool"
            }
        }, 
        "System.Reboot": {
            "description": "Initiate a reboot of the system. The return value will indicate whether the procedure has been initiated successfully.", 
            "params": {}, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "System.RemovePackages": {
            "description": "Starts removing a package. Returns true if the removal has been started successfully. Before calling this method, clients should check whether the package can be removed (canRemove set to true).", 
            "params": {
                "packageIds": [
                    "String"
                ]
            }, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "System.RollbackPackages": {
            "description": "Starts a rollback. Returns true if the rollback has been started successfully. Before calling this method, clients should check whether the package can be rolled back (canRollback set to true).", 
            "params": {
                "packageIds": [
                    "String"
                ]
            }, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "System.Shutdown": {
            "description": "Initiate a shutdown of the system. The return value will indicate whether the procedure has been initiated successfully.", 
            "params": {}, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "System.UpdatePackages": {
            "description": "Starts updating/installing packages with the given ids. Returns true if the upgrade has been started successfully. Note that it might still fail later. Before calling this method, clients should check the packages whether they are in a state where they can either be installed (no installedVersion set) or upgraded (updateAvailable set to true).", 
            "params": {
                "o:packageIds": [
                    "String"
                ]
            }, 
            "returns": {
                "success": "Bool"
            }
        }, 
        "Tags.AddTag": {
            "description": "Add a Tag. A Tag must have a deviceId OR a ruleId (call this method twice if you want to attach the same tag to a device and a rule), an appId (Use the appId of your app), a tagId (e.g. \"favorites\") and a value. Upon success, a TagAdded notification will be emitted. Calling this method twice for the same ids (device/rule, appId and tagId) but with a different value will update the tag's value and the TagValueChanged notification will be emitted.", 
            "params": {
                "tag": "$ref:Tag"
            }, 
            "returns": {
                "tagError": "$ref:TagError"
            }
        }, 
        "Tags.GetTags": {
            "description": "Get the Tags matching the given filter. Tags can be filtered by a deviceID, a ruleId, an appId, a tagId or a combination of any (however, combining deviceId and ruleId will return an empty result set).", 
            "params": {
                "o:appId": "String", 
                "o:deviceId": "Uuid", 
                "o:ruleId": "Uuid", 
                "o:tagId": "String"
            }, 
            "returns": {
                "o:tags": [
                    "$ref:Tag"
                ], 
                "tagError": "$ref:TagError"
            }
        }, 
        "Tags.RemoveTag": {
            "description": "Remove a Tag. Tag value is optional and will be disregarded. If the ids match, the tag will be deleted and a TagRemoved notification will be emitted.", 
            "params": {
                "tag": "$ref:Tag"
            }, 
            "returns": {
                "tagError": "$ref:TagError"
            }
        }
    }, 
    "notifications": {
        "Configuration.BasicConfigurationChanged": {
            "description": "Emitted whenever the basic configuration of this server changes.", 
            "params": {
                "basicConfiguration": {
                    "debugServerEnabled": "Bool", 
                    "language": "String", 
                    "serverName": "String", 
                    "serverTime": "Uint", 
                    "serverUuid": "Uuid", 
                    "timeZone": "String"
                }
            }
        }, 
        "Configuration.CloudConfigurationChanged": {
            "description": "Emitted whenever the cloud configuration is changed.", 
            "params": {
                "cloudConfiguration": {
                    "enabled": "Bool"
                }
            }
        }, 
        "Configuration.LanguageChanged": {
            "description": "Emitted whenever the language of the server changed. The Plugins, Vendors and DeviceClasses have to be reloaded to get the translated data.", 
            "params": {
                "language": "String"
            }
        }, 
        "Configuration.MqttPolicyChanged": {
            "description": "Emitted whenever a MQTT broker policy is changed.", 
            "params": {
                "policy": "$ref:MqttPolicy"
            }
        }, 
        "Configuration.MqttPolicyRemoved": {
            "description": "Emitted whenever a MQTT broker policy is removed.", 
            "params": {
                "clientId": "String"
            }
        }, 
        "Configuration.MqttServerConfigurationChanged": {
            "description": "Emitted whenever the MQTT broker configuration is changed.", 
            "params": {
                "mqttServerConfiguration": "$ref:ServerConfiguration"
            }
        }, 
        "Configuration.MqttServerConfigurationRemoved": {
            "description": "Emitted whenever a MQTT server configuration is removed.", 
            "params": {
                "id": "String"
            }
        }, 
        "Configuration.TcpServerConfigurationChanged": {
            "description": "Emitted whenever the TCP server configuration changes.", 
            "params": {
                "tcpServerConfiguration": "$ref:ServerConfiguration"
            }
        }, 
        "Configuration.TcpServerConfigurationRemoved": {
            "description": "Emitted whenever a TCP server configuration is removed.", 
            "params": {
                "id": "String"
            }
        }, 
        "Configuration.WebServerConfigurationChanged": {
            "description": "Emitted whenever the web server configuration changes.", 
            "params": {
                "webServerConfiguration": "$ref:WebServerConfiguration"
            }
        }, 
        "Configuration.WebServerConfigurationRemoved": {
            "description": "Emitted whenever a Web server configuration is removed.", 
            "params": {
                "id": "String"
            }
        }, 
        "Configuration.WebSocketServerConfigurationChanged": {
            "description": "Emitted whenever the web socket server configuration changes.", 
            "params": {
                "webSocketServerConfiguration": "$ref:ServerConfiguration"
            }
        }, 
        "Configuration.WebSocketServerConfigurationRemoved": {
            "description": "Emitted whenever a WebSocket server configuration is removed.", 
            "params": {
                "id": "String"
            }
        }, 
        "Devices.DeviceAdded": {
            "description": "Emitted whenever a Device was added.", 
            "params": {
                "device": "$ref:Device"
            }
        }, 
        "Devices.DeviceChanged": {
            "description": "Emitted whenever the params or name of a Device are changed (by EditDevice or ReconfigureDevice).", 
            "params": {
                "device": "$ref:Device"
            }
        }, 
        "Devices.DeviceRemoved": {
            "description": "Emitted whenever a Device was removed.", 
            "params": {
                "deviceId": "Uuid"
            }
        }, 
        "Devices.DeviceSettingChanged": {
            "description": "Emitted whenever the setting of a Device is changed.", 
            "params": {
                "deviceId": "Uuid", 
                "paramTypeId": "Uuid", 
                "value": "Variant"
            }
        }, 
        "Devices.PluginConfigurationChanged": {
            "description": "Emitted whenever a plugin's configuration is changed.", 
            "params": {
                "configuration": [
                    "$ref:Param"
                ], 
                "pluginId": "Uuid"
            }
        }, 
        "Devices.StateChanged": {
            "description": "Emitted whenever a State of a device changes.", 
            "params": {
                "deviceId": "Uuid", 
                "stateTypeId": "Uuid", 
                "value": "Variant"
            }
        }, 
        "Events.EventTriggered": {
            "description": "Emitted whenever an Event is triggered.", 
            "params": {
                "event": "$ref:Event"
            }
        }, 
        "JSONRPC.CloudConnectedChanged": {
            "description": "Emitted whenever the cloud connection status changes.", 
            "params": {
                "connected": "Bool", 
                "connectionState": "$ref:CloudConnectionState"
            }
        }, 
        "JSONRPC.PushButtonAuthFinished": {
            "description": "Emitted when a push button authentication reaches final state. NOTE: This notification is special. It will only be emitted to connections that did actively request a push button authentication, but also it will be emitted regardless of the notification settings. ", 
            "params": {
                "o:token": "String", 
                "success": "Bool", 
                "transactionId": "Int"
            }
        }, 
        "Logging.LogDatabaseUpdated": {
            "description": "Emitted whenever the database was updated. The database will be updated when a log entry was deleted. A log entry will be deleted when the corresponding device or a rule will be removed, or when the oldest entry of the database was deleted to keep to database in the size limits.", 
            "params": {}
        }, 
        "Logging.LogEntryAdded": {
            "description": "Emitted whenever an entry is appended to the logging system. ", 
            "params": {
                "logEntry": "$ref:LogEntry"
            }
        }, 
        "NetworkManager.NetworkStatusChanged": {
            "description": "Emitted whenever a status of a NetworkManager changes.", 
            "params": {
                "status": {
                    "networkingEnabled": "Bool", 
                    "state": "$ref:NetworkManagerState", 
                    "wirelessNetworkingEnabled": "Bool"
                }
            }
        }, 
        "NetworkManager.WiredNetworkDeviceAdded": {
            "description": "Emitted whenever a new WiredNetworkDevice was added.", 
            "params": {
                "wiredNetworkDevice": "$ref:WiredNetworkDevice"
            }
        }, 
        "NetworkManager.WiredNetworkDeviceChanged": {
            "description": "Emitted whenever the given WiredNetworkDevice has changed.", 
            "params": {
                "wiredNetworkDevice": "$ref:WiredNetworkDevice"
            }
        }, 
        "NetworkManager.WiredNetworkDeviceRemoved": {
            "description": "Emitted whenever a WiredNetworkDevice was removed.", 
            "params": {
                "interface": "String"
            }
        }, 
        "NetworkManager.WirelessNetworkDeviceAdded": {
            "description": "Emitted whenever a new WirelessNetworkDevice was added.", 
            "params": {
                "wirelessNetworkDevice": "$ref:WirelessNetworkDevice"
            }
        }, 
        "NetworkManager.WirelessNetworkDeviceChanged": {
            "description": "Emitted whenever the given WirelessNetworkDevice has changed.", 
            "params": {
                "wirelessNetworkDevice": "$ref:WirelessNetworkDevice"
            }
        }, 
        "NetworkManager.WirelessNetworkDeviceRemoved": {
            "description": "Emitted whenever a WirelessNetworkDevice was removed.", 
            "params": {
                "interface": "String"
            }
        }, 
        "Rules.RuleActiveChanged": {
            "description": "Emitted whenever the active state of a Rule changed.", 
            "params": {
                "active": "Bool", 
                "ruleId": "Uuid"
            }
        }, 
        "Rules.RuleAdded": {
            "description": "Emitted whenever a Rule was added.", 
            "params": {
                "rule": "$ref:Rule"
            }
        }, 
        "Rules.RuleConfigurationChanged": {
            "description": "Emitted whenever the configuration of a Rule changed.", 
            "params": {
                "rule": "$ref:Rule"
            }
        }, 
        "Rules.RuleRemoved": {
            "description": "Emitted whenever a Rule was removed.", 
            "params": {
                "ruleId": "Uuid"
            }
        }, 
        "System.CapabilitiesChanged": {
            "description": "Emitted whenever the system capabilities change.", 
            "params": {
                "powerManagement": "Bool", 
                "updateManagement": "Bool"
            }
        }, 
        "System.PackageAdded": {
            "description": "Emitted whenever a package is added to the list of packages.", 
            "params": {
                "package": "$ref:Package"
            }
        }, 
        "System.PackageChanged": {
            "description": "Emitted whenever a package in the list of packages changes.", 
            "params": {
                "package": "$ref:Package"
            }
        }, 
        "System.PackageRemoved": {
            "description": "Emitted whenever a package is removed from the list of packages.", 
            "params": {
                "packageId": "String"
            }
        }, 
        "System.RepositoryAdded": {
            "description": "Emitted whenever a repository is added to the list of repositories.", 
            "params": {
                "repository": "$ref:Repository"
            }
        }, 
        "System.RepositoryChanged": {
            "description": "Emitted whenever a repository in the list of repositories changes.", 
            "params": {
                "repository": "$ref:Repository"
            }
        }, 
        "System.RepositoryRemoved": {
            "description": "Emitted whenever a repository is removed from the list of repositories.", 
            "params": {
                "repositoryId": "String"
            }
        }, 
        "System.UpdateStatusChanged": {
            "description": "Emitted whenever the update status changes.", 
            "params": {
                "busy": "Bool", 
                "updateRunning": "Bool"
            }
        }, 
        "Tags.TagAdded": {
            "description": "Emitted whenever a tag is added to the system. ", 
            "params": {
                "tag": "$ref:Tag"
            }
        }, 
        "Tags.TagRemoved": {
            "description": "Emitted whenever a tag is removed from the system. ", 
            "params": {
                "tag": "$ref:Tag"
            }
        }, 
        "Tags.TagValueChanged": {
            "description": "Emitted whenever a tag's value is changed in the system. ", 
            "params": {
                "tag": "$ref:Tag"
            }
        }
    }, 
    "types": {
        "Action": {
            "actionTypeId": "Uuid", 
            "deviceId": "Uuid", 
            "o:params": [
                "$ref:Param"
            ]
        }, 
        "ActionType": {
            "displayName": "String", 
            "id": "Uuid", 
            "index": "Int", 
            "name": "String", 
            "paramTypes": [
                "$ref:ParamType"
            ]
        }, 
        "BasicType": [
            "Uuid", 
            "String", 
            "StringList", 
            "Int", 
            "Uint", 
            "Double", 
            "Bool", 
            "Variant", 
            "Color", 
            "Time", 
            "Object"
        ], 
        "BrowserIcon": [
            "BrowserIconNone", 
            "BrowserIconFolder", 
            "BrowserIconFile", 
            "BrowserIconMusic", 
            "BrowserIconVideo", 
            "BrowserIconPictures", 
            "BrowserIconApplication", 
            "BrowserIconDocument", 
            "BrowserIconPackage", 
            "BrowserIconFavorites"
        ], 
        "BrowserItem": {
            "actionTypeIds": [
                "Uuid"
            ], 
            "browsable": "Bool", 
            "description": "String", 
            "disabled": "Bool", 
            "displayName": "String", 
            "executable": "Bool", 
            "icon": "$ref:BrowserIcon", 
            "id": "String", 
            "o:mediaIcon": "$ref:MediaBrowserIcon", 
            "thumbnail": "String"
        }, 
        "CalendarItem": {
            "duration": "Uint", 
            "o:datetime": "Uint", 
            "o:repeating": "$ref:RepeatingOption", 
            "o:startTime": "Time"
        }, 
        "CloudConnectionState": [
            "CloudConnectionStateDisabled", 
            "CloudConnectionStateUnconfigured", 
            "CloudConnectionStateConnecting", 
            "CloudConnectionStateConnected"
        ], 
        "ConfigurationError": [
            "ConfigurationErrorNoError", 
            "ConfigurationErrorInvalidTimeZone", 
            "ConfigurationErrorInvalidStationName", 
            "ConfigurationErrorInvalidId", 
            "ConfigurationErrorInvalidPort", 
            "ConfigurationErrorInvalidHostAddress", 
            "ConfigurationErrorBluetoothHardwareNotAvailable", 
            "ConfigurationErrorInvalidCertificate"
        ], 
        "CreateMethod": [
            "CreateMethodUser", 
            "CreateMethodAuto", 
            "CreateMethodDiscovery"
        ], 
        "Device": {
            "thingClassId": "Uuid", 
            "id": "Uuid", 
            "name": "String", 
            "o:parentId": "Uuid", 
            "params": [
                "$ref:Param"
            ], 
            "settings": [
                "$ref:Param"
            ], 
            "setupComplete": "Bool", 
            "states": [
                {
                    "stateTypeId": "Uuid", 
                    "value": "Variant"
                }
            ]
        }, 
        "DeviceClass": {
            "actionTypes": [
                "$ref:ActionType"
            ], 
            "browsable": "Bool", 
            "browserItemActionTypes": [
                "$ref:ActionType"
            ], 
            "createMethods": [
                "$ref:CreateMethod"
            ], 
            "discoveryParamTypes": [
                "$ref:ParamType"
            ], 
            "displayName": "String", 
            "eventTypes": [
                "$ref:EventType"
            ], 
            "id": "Uuid", 
            "interfaces": [
                "String"
            ], 
            "name": "String", 
            "paramTypes": [
                "$ref:ParamType"
            ], 
            "pluginId": "Uuid", 
            "settingsTypes": [
                "$ref:ParamType"
            ], 
            "setupMethod": "$ref:SetupMethod", 
            "stateTypes": [
                "$ref:StateType"
            ], 
            "vendorId": "Uuid"
        }, 
        "DeviceDescriptor": {
            "description": "String", 
            "deviceId": "Uuid", 
            "deviceParams": [
                "$ref:Param"
            ], 
            "id": "Uuid", 
            "title": "String"
        }, 
        "DeviceError": [
            "DeviceErrorNoError", 
            "DeviceErrorPluginNotFound", 
            "DeviceErrorVendorNotFound", 
            "DeviceErrorDeviceNotFound", 
            "DeviceErrorDeviceClassNotFound", 
            "DeviceErrorActionTypeNotFound", 
            "DeviceErrorStateTypeNotFound", 
            "DeviceErrorEventTypeNotFound", 
            "DeviceErrorDeviceDescriptorNotFound", 
            "DeviceErrorMissingParameter", 
            "DeviceErrorInvalidParameter", 
            "DeviceErrorSetupFailed", 
            "DeviceErrorDuplicateUuid", 
            "DeviceErrorCreationMethodNotSupported", 
            "DeviceErrorSetupMethodNotSupported", 
            "DeviceErrorHardwareNotAvailable", 
            "DeviceErrorHardwareFailure", 
            "DeviceErrorAuthenticationFailure", 
            "DeviceErrorDeviceInUse", 
            "DeviceErrorDeviceInRule", 
            "DeviceErrorDeviceIsChild", 
            "DeviceErrorPairingTransactionIdNotFound", 
            "DeviceErrorParameterNotWritable", 
            "DeviceErrorItemNotFound", 
            "DeviceErrorItemNotExecutable", 
            "DeviceErrorUnsupportedFeature", 
            "DeviceErrorTimeout"
        ], 
        "Event": {
            "deviceId": "Uuid", 
            "eventTypeId": "Uuid", 
            "o:params": [
                "$ref:Param"
            ]
        }, 
        "EventDescriptor": {
            "o:deviceId": "Uuid", 
            "o:eventTypeId": "Uuid", 
            "o:interface": "String", 
            "o:interfaceEvent": "String", 
            "o:paramDescriptors": [
                "$ref:ParamDescriptor"
            ]
        }, 
        "EventType": {
            "displayName": "String", 
            "id": "Uuid", 
            "index": "Int", 
            "name": "String", 
            "paramTypes": [
                "$ref:ParamType"
            ]
        }, 
        "InputType": [
            "InputTypeNone", 
            "InputTypeTextLine", 
            "InputTypeTextArea", 
            "InputTypePassword", 
            "InputTypeSearch", 
            "InputTypeMail", 
            "InputTypeIPv4Address", 
            "InputTypeIPv6Address", 
            "InputTypeUrl", 
            "InputTypeMacAddress"
        ], 
        "LogEntry": {
            "loggingLevel": "$ref:LoggingLevel", 
            "o:active": "Bool", 
            "o:deviceId": "Uuid", 
            "o:errorCode": "String", 
            "o:eventType": "$ref:LoggingEventType", 
            "o:itemId": "String", 
            "o:typeId": "Uuid", 
            "o:value": "String", 
            "source": "$ref:LoggingSource", 
            "timestamp": "Int"
        }, 
        "LoggingError": [
            "LoggingErrorNoError", 
            "LoggingErrorLogEntryNotFound", 
            "LoggingErrorInvalidFilterParameter"
        ], 
        "LoggingEventType": [
            "LoggingEventTypeTrigger", 
            "LoggingEventTypeActiveChange", 
            "LoggingEventTypeEnabledChange", 
            "LoggingEventTypeActionsExecuted", 
            "LoggingEventTypeExitActionsExecuted"
        ], 
        "LoggingLevel": [
            "LoggingLevelInfo", 
            "LoggingLevelAlert"
        ], 
        "LoggingSource": [
            "LoggingSourceSystem", 
            "LoggingSourceEvents", 
            "LoggingSourceActions", 
            "LoggingSourceStates", 
            "LoggingSourceRules", 
            "LoggingSourceBrowserActions"
        ], 
        "MediaBrowserIcon": [
            "MediaBrowserIconNone", 
            "MediaBrowserIconPlaylist", 
            "MediaBrowserIconRecentlyPlayed", 
            "MediaBrowserIconLibrary", 
            "MediaBrowserIconMusicLibrary", 
            "MediaBrowserIconVideoLibrary", 
            "MediaBrowserIconPictureLibrary", 
            "MediaBrowserIconDisk", 
            "MediaBrowserIconUSB", 
            "MediaBrowserIconNetwork", 
            "MediaBrowserIconAux", 
            "MediaBrowserIconSpotify", 
            "MediaBrowserIconAmazon", 
            "MediaBrowserIconTuneIn", 
            "MediaBrowserIconSiriusXM", 
            "MediaBrowserIconVTuner", 
            "MediaBrowserIconTidal", 
            "MediaBrowserIconAirable", 
            "MediaBrowserIconDeezer", 
            "MediaBrowserIconNapster", 
            "MediaBrowserIconSoundCloud"
        ], 
        "MqttPolicy": {
            "allowedPublishTopicFilters": "StringList", 
            "allowedSubscribeTopicFilters": "StringList", 
            "clientId": "String", 
            "password": "String", 
            "username": "String"
        }, 
        "Namespace": [
            "Actions", 
            "Configuration", 
            "Devices", 
            "Events", 
            "JSONRPC", 
            "Logging", 
            "NetworkManager", 
            "Rules", 
            "States", 
            "System", 
            "Tags"
        ], 
        "NetworkDeviceState": [
            "NetworkDeviceStateUnknown", 
            "NetworkDeviceStateUnmanaged", 
            "NetworkDeviceStateUnavailable", 
            "NetworkDeviceStateDisconnected", 
            "NetworkDeviceStatePrepare", 
            "NetworkDeviceStateConfig", 
            "NetworkDeviceStateNeedAuth", 
            "NetworkDeviceStateIpConfig", 
            "NetworkDeviceStateIpCheck", 
            "NetworkDeviceStateSecondaries", 
            "NetworkDeviceStateActivated", 
            "NetworkDeviceStateDeactivating", 
            "NetworkDeviceStateFailed"
        ], 
        "NetworkManagerError": [
            "NetworkManagerErrorNoError", 
            "NetworkManagerErrorUnknownError", 
            "NetworkManagerErrorWirelessNotAvailable", 
            "NetworkManagerErrorAccessPointNotFound", 
            "NetworkManagerErrorNetworkInterfaceNotFound", 
            "NetworkManagerErrorInvalidNetworkDeviceType", 
            "NetworkManagerErrorWirelessNetworkingDisabled", 
            "NetworkManagerErrorWirelessConnectionFailed", 
            "NetworkManagerErrorNetworkingDisabled", 
            "NetworkManagerErrorNetworkManagerNotAvailable"
        ], 
        "NetworkManagerState": [
            "NetworkManagerStateUnknown", 
            "NetworkManagerStateAsleep", 
            "NetworkManagerStateDisconnected", 
            "NetworkManagerStateDisconnecting", 
            "NetworkManagerStateConnecting", 
            "NetworkManagerStateConnectedLocal", 
            "NetworkManagerStateConnectedSite", 
            "NetworkManagerStateConnectedGlobal"
        ], 
        "Package": {
            "canRemove": "Bool", 
            "candidateVersion": "String", 
            "changelog": "String", 
            "displayName": "String", 
            "id": "String", 
            "installedVersion": "String", 
            "rollbackAvailable": "Bool", 
            "summary": "String", 
            "updateAvailable": "Bool"
        }, 
        "Param": {
            "paramTypeId": "Uuid", 
            "value": "$ref:BasicType"
        }, 
        "ParamDescriptor": {
            "o:paramName": "Uuid", 
            "o:paramTypeId": "Uuid", 
            "operator": "$ref:ValueOperator", 
            "value": "$ref:BasicType"
        }, 
        "ParamType": {
            "displayName": "String", 
            "id": "Uuid", 
            "index": "Int", 
            "name": "String", 
            "o:allowedValues": [
                "Variant"
            ], 
            "o:defaultValue": "Variant", 
            "o:inputType": "$ref:InputType", 
            "o:maxValue": "Variant", 
            "o:minValue": "Variant", 
            "o:readOnly": "Bool", 
            "o:unit": "$ref:Unit", 
            "type": "$ref:BasicType"
        }, 
        "Plugin": {
            "displayName": "String", 
            "id": "Uuid", 
            "name": "String", 
            "paramTypes": [
                "$ref:ParamType"
            ]
        }, 
        "RemovePolicy": [
            "RemovePolicyCascade", 
            "RemovePolicyUpdate"
        ], 
        "RepeatingMode": [
            "RepeatingModeNone", 
            "RepeatingModeHourly", 
            "RepeatingModeDaily", 
            "RepeatingModeWeekly", 
            "RepeatingModeMonthly", 
            "RepeatingModeYearly"
        ], 
        "RepeatingOption": {
            "mode": "$ref:RepeatingMode", 
            "o:monthDays": [
                "Int"
            ], 
            "o:weekDays": [
                "Int"
            ]
        }, 
        "Repository": {
            "displayName": "String", 
            "enabled": "Bool", 
            "id": "String"
        }, 
        "Rule": {
            "actions": [
                "$ref:RuleAction"
            ], 
            "active": "Bool", 
            "enabled": "Bool", 
            "eventDescriptors": [
                "$ref:EventDescriptor"
            ], 
            "executable": "Bool", 
            "exitActions": [
                "$ref:RuleAction"
            ], 
            "id": "Uuid", 
            "name": "String", 
            "stateEvaluator": "$ref:StateEvaluator", 
            "timeDescriptor": "$ref:TimeDescriptor"
        }, 
        "RuleAction": {
            "o:actionTypeId": "Uuid", 
            "o:browserItemId": "String", 
            "o:deviceId": "Uuid", 
            "o:interface": "String", 
            "o:interfaceAction": "String", 
            "o:ruleActionParams": [
                "$ref:RuleActionParam"
            ]
        }, 
        "RuleActionParam": {
            "o:eventParamTypeId": "Uuid", 
            "o:eventTypeId": "Uuid", 
            "o:paramName": "String", 
            "o:paramTypeId": "Uuid", 
            "o:stateDeviceId": "Uuid", 
            "o:stateTypeId": "Uuid", 
            "o:value": "$ref:BasicType"
        }, 
        "RuleDescription": {
            "active": "Bool", 
            "enabled": "Bool", 
            "executable": "Bool", 
            "id": "Uuid", 
            "name": "String"
        }, 
        "RuleError": [
            "RuleErrorNoError", 
            "RuleErrorInvalidRuleId", 
            "RuleErrorRuleNotFound", 
            "RuleErrorDeviceNotFound", 
            "RuleErrorEventTypeNotFound", 
            "RuleErrorStateTypeNotFound", 
            "RuleErrorActionTypeNotFound", 
            "RuleErrorInvalidParameter", 
            "RuleErrorInvalidRuleFormat", 
            "RuleErrorMissingParameter", 
            "RuleErrorInvalidRuleActionParameter", 
            "RuleErrorInvalidStateEvaluatorValue", 
            "RuleErrorTypesNotMatching", 
            "RuleErrorNotExecutable", 
            "RuleErrorInvalidTimeDescriptor", 
            "RuleErrorInvalidRepeatingOption", 
            "RuleErrorInvalidCalendarItem", 
            "RuleErrorInvalidTimeEventItem", 
            "RuleErrorContainsEventBasesAction", 
            "RuleErrorNoExitActions", 
            "RuleErrorInterfaceNotFound"
        ], 
        "ServerConfiguration": {
            "address": "String", 
            "authenticationEnabled": "Bool", 
            "id": "String", 
            "port": "Uint", 
            "sslEnabled": "Bool"
        }, 
        "SetupMethod": [
            "SetupMethodJustAdd", 
            "SetupMethodDisplayPin", 
            "SetupMethodEnterPin", 
            "SetupMethodPushButton", 
            "SetupMethodUserAndPassword", 
            "SetupMethodOAuth"
        ], 
        "State": {
            "deviceId": "Uuid", 
            "stateTypeId": "Uuid", 
            "value": "Variant"
        }, 
        "StateDescriptor": {
            "o:deviceId": "Uuid", 
            "o:interface": "String", 
            "o:interfaceState": "String", 
            "o:stateTypeId": "Uuid", 
            "operator": "$ref:ValueOperator", 
            "value": "Variant"
        }, 
        "StateEvaluator": {
            "o:childEvaluators": [
                "$ref:StateEvaluator"
            ], 
            "o:operator": "$ref:StateOperator", 
            "o:stateDescriptor": "$ref:StateDescriptor"
        }, 
        "StateOperator": [
            "StateOperatorAnd", 
            "StateOperatorOr"
        ], 
        "StateType": {
            "defaultValue": "Variant", 
            "displayName": "String", 
            "id": "Uuid", 
            "index": "Int", 
            "name": "String", 
            "o:maxValue": "Variant", 
            "o:minValue": "Variant", 
            "o:possibleValues": [
                "Variant"
            ], 
            "o:unit": "$ref:Unit", 
            "type": "$ref:BasicType"
        }, 
        "Tag": {
            "appId": "String", 
            "o:deviceId": "Uuid", 
            "o:ruleId": "Uuid", 
            "o:value": "String", 
            "tagId": "String"
        }, 
        "TagError": [
            "TagErrorNoError", 
            "TagErrorDeviceNotFound", 
            "TagErrorRuleNotFound", 
            "TagErrorTagNotFound"
        ], 
        "TimeDescriptor": {
            "o:calendarItems": [
                "$ref:CalendarItem"
            ], 
            "o:timeEventItems": [
                "$ref:TimeEventItem"
            ]
        }, 
        "TimeEventItem": {
            "o:datetime": "Uint", 
            "o:repeating": "$ref:RepeatingOption", 
            "o:time": "Time"
        }, 
        "TokenInfo": {
            "creationTime": "Uint", 
            "deviceName": "String", 
            "id": "Uuid", 
            "userName": "String"
        }, 
        "Unit": [
            "UnitNone", 
            "UnitSeconds", 
            "UnitMinutes", 
            "UnitHours", 
            "UnitUnixTime", 
            "UnitMeterPerSecond", 
            "UnitKiloMeterPerHour", 
            "UnitDegree", 
            "UnitRadiant", 
            "UnitDegreeCelsius", 
            "UnitDegreeKelvin", 
            "UnitMired", 
            "UnitMilliBar", 
            "UnitBar", 
            "UnitPascal", 
            "UnitHectoPascal", 
            "UnitAtmosphere", 
            "UnitLumen", 
            "UnitLux", 
            "UnitCandela", 
            "UnitMilliMeter", 
            "UnitCentiMeter", 
            "UnitMeter", 
            "UnitKiloMeter", 
            "UnitGram", 
            "UnitKiloGram", 
            "UnitDezibel", 
            "UnitBpm", 
            "UnitKiloByte", 
            "UnitMegaByte", 
            "UnitGigaByte", 
            "UnitTeraByte", 
            "UnitMilliWatt", 
            "UnitWatt", 
            "UnitKiloWatt", 
            "UnitKiloWattHour", 
            "UnitEuroPerMegaWattHour", 
            "UnitEuroCentPerKiloWattHour", 
            "UnitPercentage", 
            "UnitPartsPerMillion", 
            "UnitEuro", 
            "UnitDollar", 
            "UnitHertz", 
            "UnitAmpere", 
            "UnitMilliAmpere", 
            "UnitVolt", 
            "UnitMilliVolt", 
            "UnitVoltAmpere", 
            "UnitVoltAmpereReactive", 
            "UnitAmpereHour", 
            "UnitMicroSiemensPerCentimeter", 
            "UnitDuration"
        ], 
        "UserError": [
            "UserErrorNoError", 
            "UserErrorBackendError", 
            "UserErrorInvalidUserId", 
            "UserErrorDuplicateUserId", 
            "UserErrorBadPassword", 
            "UserErrorTokenNotFound", 
            "UserErrorPermissionDenied"
        ], 
        "ValueOperator": [
            "ValueOperatorEquals", 
            "ValueOperatorNotEquals", 
            "ValueOperatorLess", 
            "ValueOperatorGreater", 
            "ValueOperatorLessOrEqual", 
            "ValueOperatorGreaterOrEqual"
        ], 
        "Vendor": {
            "displayName": "String", 
            "id": "Uuid", 
            "name": "String"
        }, 
        "WebServerConfiguration": {
            "address": "String", 
            "authenticationEnabled": "Bool", 
            "id": "String", 
            "port": "Uint", 
            "sslEnabled": "Bool"
        }, 
        "WiredNetworkDevice": {
            "bitRate": "String", 
            "interface": "String", 
            "macAddress": "String", 
            "pluggedIn": "Bool", 
            "state": "$ref:NetworkDeviceState"
        }, 
        "WirelessAccessPoint": {
            "frequency": "Double", 
            "macAddress": "String", 
            "protected": "Bool", 
            "signalStrength": "Int", 
            "ssid": "String"
        }, 
        "WirelessNetworkDevice": {
            "bitRate": "String", 
            "interface": "String", 
            "macAddress": "String", 
            "o:currentAccessPoint": "$ref:WirelessAccessPoint", 
            "state": "$ref:NetworkDeviceState"
        }
    }
}
\endcode
*/
